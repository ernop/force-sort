<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Force‑Directed People Graph</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/css/select2.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.full.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.js"></script>
  <style>
    html,body{margin:0;height:100%;background:#fff;font-family:Arial,Helvetica,sans-serif}
    #topControls,#bottomControls{display:flex;gap:12px;padding:8px;flex-wrap:wrap}
    #topControls{border-bottom:1px solid #ddd}
    #bottomControls{border-top:1px solid #ddd}
    #graph{width:100%;height:calc(100% - 120px)} /* two control bars */

    textarea#export{display:none}
    textarea#export.unsaved{background:#fff3c4}

    #searchBox{
      position:fixed;
      bottom:10px;
      right:10px;
      width:200px;
      display:flex;
      flex-direction:column;
      gap:8px;
      background:#fff;
      border:1px solid #ccc;
      padding:8px;
      box-shadow:0 2px 6px rgba(0,0,0,0.2);
      border-radius:4px;
    }
    #searchBox input{padding:4px;}
    #focusBox{
      position:fixed;
      bottom:10px;
      right:220px;
      width:200px;
      display:flex;
      flex-direction:column;
      gap:8px;
      background:#fff;
      border:1px solid #ccc;
      padding:8px;
      box-shadow:0 2px 6px rgba(0,0,0,0.2);
      border-radius:4px;
    }
    .node.search-match circle{stroke:#ff5722;stroke-width:4px;}
    .node.focus-node circle{stroke:#0a0;stroke-width:4px;}

    .node circle{fill:#a7d3ff;stroke:#fff;stroke-width:2px;cursor:grab}
    .node-image{pointer-events:none}
    .year-labels text{font-size:12px;fill:#888}
    
    .link{stroke:#555;stroke-width:1.5px;fill:none;marker-end:url(#arrow)}
    /* highlight lines thicker so search hits stand out */
    .link.highlight{stroke:red;stroke-width:6px}
    .link.focus-edge{stroke:#0a0;stroke-width:3px}
    
    text{font-size:12px;pointer-events:none;fill:#000}
    .label{pointer-events:all;cursor:pointer}
    .link-hit{stroke:transparent;stroke-width:14px;fill:none;cursor:pointer}
    button{cursor:pointer}
    /* keep year group headers visible without covering search field */
    .select2-results__group{position:sticky;bottom:0;background:#fff;margin-top:4px}
    #edgePopup{position:absolute;background:#ffffe0;border:1px solid #aaa;border-radius:4px;padding:4px;font-size:12px;box-shadow:0 2px 4px rgba(0,0,0,0.2);display:none}
    #edgePopup input{width:120px}
    #edgePopup .actions{display:flex;gap:4px;margin-top:4px}

    #nodePopup{position:absolute;background:#ffffe0;border:1px solid #aaa;border-radius:4px;padding:4px;font-size:12px;box-shadow:0 2px 4px rgba(0,0,0,0.2);display:none}
    #nodePopup input{width:120px;display:block;margin-top:4px}
    #nodePopup .actions{display:flex;gap:4px;margin-top:4px}
    #nodePopup .hint{font-style:italic;margin-top:4px;font-size:11px}
    #nodePopupImages{display:flex;flex-wrap:wrap;gap:4px;margin-top:4px}
    #nodePopupImages .item{position:relative}
    #nodePopupImages img{width:44px;height:44px;border:1px solid #ccc}
    #nodePopupImages .actions{position:absolute;top:0;right:0;display:flex;flex-direction:column}
    #nodePopupImages button{padding:0 2px;font-size:10px;background:#fff;border:1px solid #ccc;cursor:pointer}
    
    /* bigger add buttons */
    #addNodeBtn,#addEdgeBtn{font-size:16px;padding:6px 12px}

    #layoutLabel{margin-left:auto}
  </style>
</head>
<body>
  <!-- top toolbar -->
  <div id="topControls">
    <button id="perturb">Perturb</button>
    <button id="dampen">Remove Momentum</button>
    <label>Charge <input id="chargeRange" type="range" min="-1000" max="0" value="-300"></label>
    <label>Link&nbsp;Dist <input id="linkRange" type="range" min="30" max="300" value="150"></label>
    <label id="layoutLabel">Layout
      <select id="layoutSelect">
        <option value="force">Force</option>
        <option value="tiers">Tiers</option>
      </select>
    </label>
  </div>

  <!-- graph area -->
  <div id="graph"></div>

  <!-- bottom toolbar -->
<div id="bottomControls">
  <label>Add Node
    <input id="newNodeName" type="text" placeholder="Name">
    <input id="newNodeYear" type="text" placeholder="Birth Year">
    <button id="addNodeBtn">Add</button>
  </label>
  <label>Add Edge from
    <select id="edgeFrom"></select> to
    <select id="edgeTo"></select> label
    <input id="edgeLabel" type="text" placeholder="Label" list="presetLabels">
    <button id="addEdgeBtn">Add</button>
  </label>
  <datalist id="presetLabels">
    <option value="read">
    <option value="liked">
    <option value="inspired by">
    <option value="friend">
    </datalist>
</div>

  <div id="searchBox">
    <input id="searchInput" type="text" placeholder="search">
    <div id="yearSlider"></div>
  </div>
  <div id="focusBox" style="display:none">
    <div id="focusLabel"></div>
    <label>How far from focus to show:
      <input id="focusRange" type="range" min="1" max="5" value="1">
      <span id="focusNum">1</span>
    </label>
  </div>

  <!-- export area -->
  <textarea id="export" readonly></textarea>

  <!-- edge action popup -->
  <div id="edgePopup">
    <input id="edgePopupLabel" type="text">
    <div class="actions">
      <button id="edgePopupSave">Save</button>
      <button id="edgePopupReverse">Reverse</button>
      <button id="edgePopupDelete">Delete</button>
      <button id="edgePopupClose">X</button>
    </div>
  </div>

  <!-- node action popup -->
  <div id="nodePopup">
    <input id="nodePopupName" type="text" placeholder="Name">
    <input id="nodePopupYear" type="text" placeholder="Birth Year">
    <div class="actions">
      <button id="nodePopupSave">Save</button>
      <button id="nodePopupDelete">Delete</button>
      <button id="nodePopupClose">X</button>
    </div>
    <div class="hint">Paste an image while this popup is open</div>
    <div id="nodePopupImages"></div>
  </div>

<script>
/* ---------- data loading ---------- */
/*
  data.json format:
  {
    "nodes": [
      {"id":1,"name":"Name","birth_year":"1879","images":["images/1.png"]}
    ],
    "links": [{"id1":1,"id2":2,"label":"label"}]
  }
  birth_year is optional. Each node always has an "images" array which may be empty.
*/
let nodes = [];
let links = [];
let visibleLinks = [];
const nodeById = new Map();
let nextNodeId = 1;
let focusNodeId = null;
let focusDepth = 1;
function loadData(){
  return fetch("data.json")
    .then(r=>r.json())
    .then(data=>{
      nodes = data.nodes || [];
      links = data.links || [];
      visibleLinks = links.slice();
      nodes.forEach(n=>{
        n.images = Array.isArray(n.images) ? n.images : [];
        n.image = n.images[0] || null;
        nodeById.set(n.id,n);
      });
      nextNodeId = Math.max(0,...nodes.map(n=>n.id)) + 1;
    });
}

function buildSimLinks(arr) {
  return arr.map(e => ({
    source : nodeById.get(e.id1),
    target : nodeById.get(e.id2),
    label  : e.label,
    dir    : e.id1 < e.id2 ? 1 : -1,   // A→B “up”, B→A “down”
    link   : e                          // reference to original data
  }));
}

/* ---------- SVG & defs ---------- */
const graphDiv = document.getElementById('graph');
const width    = graphDiv.clientWidth;
const height   = graphDiv.clientHeight;

const svg = d3.select(graphDiv).append('svg')
              .attr('width',width)
              .attr('height',height);

/* ---------- zoom & pan ---------- */
const zoom = d3.zoom()
  .scaleExtent([0.1, 4])                     // min / max zoom
  .on('zoom', event => g.attr('transform', event.transform));

svg.call(zoom).on('dblclick.zoom', null);     // disable dblclick-to-zoom

const defs = svg.append('defs');
defs.append('marker')
   .attr('id','arrow')
   .attr('viewBox','0 -5 10 10')
   .attr('refX',32).attr('refY',0) /* offset beyond circle */
   .attr('markerWidth',8).attr('markerHeight',8)
   .attr('orient','auto')
   .append('path').attr('d','M0,-5L10,0L0,5').attr('fill','#555');

defs.append('clipPath')
    .attr('id','nodeClip')
    .append('circle')
    .attr('r',22);

const g = svg.append('g');
const linkGroup = g.append('g').attr('class','links');
let  linkSel     = linkGroup.selectAll('path.link');
let  linkHitSel  = linkGroup.selectAll('path.link-hit');
let  labelSel    = linkGroup.selectAll('text.label');
const yearLabelGroup = g.append('g').attr('class','year-labels').style('display','none');
let  yearLabelSel = yearLabelGroup.selectAll('text');
let  nodeSel     = g.selectAll('.node');

const BASE_COLLISION  = 40;  // default collision distance
const LABEL_OFFSET    = 6;   // px text sits beyond circle

/* ---------- D3 forces ---------- */
const chargeInput = document.getElementById('chargeRange');
const linkInput   = document.getElementById('linkRange');
const layoutSelect= document.getElementById('layoutSelect');
let   layoutMode  = layoutSelect.value;
const tierSpacing = 100;
const yearSpacing = 20;
const exportArea  = document.getElementById('export');   // ← new
const searchInput  = document.getElementById('searchInput');
const yearSlider   = document.getElementById('yearSlider');
const edgePopup       = document.getElementById('edgePopup');
const edgePopupLabel  = document.getElementById('edgePopupLabel');
const edgePopupSave   = document.getElementById('edgePopupSave');
const edgePopupReverse= document.getElementById('edgePopupReverse');
const edgePopupDelete = document.getElementById('edgePopupDelete');
const edgePopupClose  = document.getElementById('edgePopupClose');
let   edgePopupLink   = null;

const nodePopup       = document.getElementById('nodePopup');
const nodePopupName   = document.getElementById('nodePopupName');
const nodePopupYear   = document.getElementById('nodePopupYear');
const nodePopupSave   = document.getElementById('nodePopupSave');
const nodePopupDelete = document.getElementById('nodePopupDelete');
const nodePopupClose  = document.getElementById('nodePopupClose');
const nodePopupImages = document.getElementById('nodePopupImages');
const focusBox        = document.getElementById('focusBox');
const focusLabel      = document.getElementById('focusLabel');
const focusRange      = document.getElementById('focusRange');
const focusNum        = document.getElementById('focusNum');
let   nodePopupId     = null;

const simulation = d3.forceSimulation(nodes)
  .force('link',
         d3.forceLink()                       // links injected later
           .id(d => d.id)
           .distance(() => +linkRange.value))
  .force('charge',
         d3.forceManyBody()
           .strength(() => +chargeRange.value)        // live-updates with slider
           .distanceMax(1_000000))                       // repulse across whole graph
  .force('center', d3.forceCenter(width / 2, height / 2))
  .force('collision', d3.forceCollide().radius(40))
  .alphaDecay(0.001)                                  // cools more slowly → runs longer
  .on('tick', ticked);

function ticked(){
  /* ---------- arrow path ---------- */
  const r = 22;
  const pathD = d => {
    const dx   = d.target.x - d.source.x,
          dy   = d.target.y - d.source.y,
          dist = Math.hypot(dx, dy) || 1,
          tEnd   = (dist - r) / dist;  // line ends at target circle

    return `M${d.source.x},${d.source.y}L${d.source.x + dx*tEnd},${d.source.y + dy*tEnd}`;
  };

  linkSel.attr('d', pathD);
  linkHitSel.attr('d', pathD);

  /* keep nodes visible & movable */
  nodeSel.attr('transform', d => `translate(${d.x},${d.y})`);
  
	/* ---------- node name “radial-slot” positioning ---------- */
// gather incident edge angles for each node this tick
const incident = new Map();  // node.id → [angles]

visibleLinks.forEach(l => {
  const src = nodeById.get(l.id1),
        tgt = nodeById.get(l.id2);
  if (!src || !tgt) return;

  const a = Math.atan2(tgt.y - src.y, tgt.x - src.x);   // angle src→tgt
  (incident.get(src.id) || incident.set(src.id, []).get(src.id)).push(a);
  (incident.get(tgt.id) || incident.set(tgt.id, []).get(tgt.id)).push(a + Math.PI); // opposite at tgt
});

// eight slot angles (0°,45°,…)
const slots       = Array.from({length:8}, (_,i)=>i*Math.PI/4);
const labelRadius = 28; // px from node center
const labelOffset = 6; // px beyond circle

nodeSel.select('text').each(function(d){
  const edges = incident.get(d.id) || [];
  // choose slot farthest from every incident edge
  let bestAng = 0, bestScore = -1;
  slots.forEach(s => {
    const score = edges.length
      ? Math.min(...edges.map(e => Math.abs(Math.atan2(Math.sin(s-e), Math.cos(s-e)))))
      : Math.PI;  // isolated node
    if (score > bestScore){ bestScore = score; bestAng = s; }
  });

  const tx = Math.cos(bestAng) * labelRadius,
        ty = Math.sin(bestAng) * labelRadius;

  d3.select(this)
    .attr('x', tx)
    .attr('y', ty)
    .attr('dominant-baseline', 'central')
    .attr('text-anchor',
          Math.abs(Math.cos(bestAng)) < 0.3 ? 'middle' :
          (Math.cos(bestAng) > 0 ? 'start' : 'end'));
});
	
  /* ---------- label position ---------- */
  const delta     = 10;   // perpendicular offset (px)
  const fracToTgt = 0.65; // label sits 65 % toward target, just behind arrow

  labelSel.each(function (d) {
    /* use lower-ID → higher-ID to define perpendicular direction */
    const forward = d.source.id < d.target.id;
    const s       = forward ? d.source : d.target;
    const t       = forward ? d.target : d.source;
    const dx      = t.x - s.x,
          dy      = t.y - s.y,
          dist    = Math.hypot(dx, dy) || 1,
          px      = -dy / dist,            // unit perpendicular
          py      =  dx / dist,
          dir     = forward ? 1 : -1;      // “up” or “down”

    const lx = d.source.x + (d.target.x - d.source.x) * fracToTgt;
    const ly = d.source.y + (d.target.y - d.source.y) * fracToTgt;

    d.cx = lx + delta * px * dir;
    d.cy = ly + delta * py * dir;
  })
  .attr('x', d => d.cx)
  .attr('y', d => d.cy)
  .attr('text-anchor', 'middle')
  .attr('dominant-baseline', 'central')
  .attr('transform', d => {
    let ang = Math.atan2(d.target.y - d.source.y,
                         d.target.x - d.source.x) * 180 / Math.PI;
    if (ang > 90 || ang < -90) ang += 180;   // keep text upright
    return `rotate(${ang},${d.cx},${d.cy})`;
  });
}

/* ---------- helpers ---------- */

function formatNodeLabel(n){
  return (n.birth_year !== undefined && n.birth_year !== null && n.birth_year !== '')
         ? `${n.name} (${n.birth_year})`
         : n.name;
}

function populateSelects() {
  const groups = new Map();
  nodes.forEach(n => {
    const key = n.birth_year && n.birth_year !== '' ? n.birth_year : 'Unknown';
    if (!groups.has(key)) groups.set(key, []);
    groups.get(key).push(n);
  });
  const sortedYears = Array.from(groups.keys()).sort((a, b) => {
    const ay = a === 'Unknown' ? Infinity : parseInt(a, 10);
    const by = b === 'Unknown' ? Infinity : parseInt(b, 10);
    return ay - by;
  });

  const opts = sortedYears.map(y => {
    const items = groups.get(y).sort((a,b)=>a.name.localeCompare(b.name))
      .map(n => `<option value="${n.id}">${formatNodeLabel(n)}</option>`)
      .join('');
    return `<optgroup label="${y}">${items}</optgroup>`;
  }).join('');

  const fromVal = edgeFrom.value;
  const toVal = edgeTo.value;

  // Destroy existing Select2 instances to prevent event duplication
  if ($(edgeFrom).hasClass('select2-hidden-accessible')) {
    $(edgeFrom).select2('destroy');
  }
  if ($(edgeTo).hasClass('select2-hidden-accessible')) {
    $(edgeTo).select2('destroy');
  }

  // Update options
  edgeFrom.innerHTML = opts;
  edgeTo.innerHTML = opts;

  // Restore selected values
  $(edgeFrom).val(fromVal);
  $(edgeTo).val(toVal);

  // Initialize Select2 with enhanced options
  const select2Options = {
    width: '200px', // Adjust width as needed for your layout
    minimumResultsForSearch: 0 // Always show search box
  };

  $(edgeFrom).select2(select2Options);
  $(edgeTo).select2(select2Options);
}


exportArea.addEventListener('click', () => {
  navigator.clipboard.writeText(exportArea.value)
    .then(() => exportArea.classList.remove('unsaved'));
});

function saveDataToServer(text){
  fetch('/save_data', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: text
  });
}

function refreshExport(markDirty = true) {
  exportArea.value = JSON.stringify({
    nodes: nodes.map(n => {
      const obj = { id: n.id, name: n.name };
      if (n.birth_year !== undefined && n.birth_year !== null && n.birth_year !== '') obj.birth_year = n.birth_year;
      obj.images = n.images.slice();
      return obj;
    }),
    links
  }, null, 2);
  if (markDirty) {
    exportArea.classList.add('unsaved');
    saveDataToServer(exportArea.value);
  } else {
    exportArea.classList.remove('unsaved');
  }
}

function computeTiers() {

  const lvl = new Map(nodes.map(n => [n.id, 0]));
  for (let iter = 0; iter < nodes.length; iter++) {
    let changed = false;
    links.forEach(l => {
      const s = lvl.get(l.id1) || 0;
      const t = lvl.get(l.id2) || 0;
      if (t <= s) {
        lvl.set(l.id2, s + 1);
        changed = true;
      }
    });
    if (!changed) break;
  }
  nodes.forEach(n => n.tier = lvl.get(n.id) || 0);
}

function computeYearLayout() {
  const years = nodes
    .map(n => parseInt(n.birth_year, 10))
    .filter(y => !isNaN(y));
  let minYear, maxYear;
  if (years.length === 0) {
    minYear = maxYear = new Date().getFullYear();
  } else {
    minYear = Math.min(...years);
    maxYear = Math.max(...years);
  }

  const rows = new Map();
  nodes.forEach(n => {
    const y = parseInt(n.birth_year, 10);
    const key = isNaN(y) ? 'unknown' : y;
    if (!rows.has(key)) rows.set(key, []);
    rows.get(key).push(n);
  });

  rows.forEach((row, key) => {
    row.forEach((n, i) => {
      const yr = parseInt(n.birth_year, 10);
      const line = isNaN(yr) ? maxYear + 1 : yr;
      n.x = 100 + i * 150;
      n.y = (line - minYear) * yearSpacing + 40;
    });
  });

  const labelData = Array.from(rows.keys()).map(k => ({
    key: k,
    line: isNaN(parseInt(k,10)) ? maxYear + 1 : parseInt(k,10)
  }));
  yearLabelSel = yearLabelGroup.selectAll('text').data(labelData, d=>d.key)
    .join('text')
      .text(d => d.key === 'unknown' ? 'Unknown' : d.key)
      .attr('text-anchor','end');
  yearLabelSel.attr('x', 80)
             .attr('y', d => (d.line - minYear) * yearSpacing + 55);
}

function applyLayoutForces() {
  simulation.stop();



  // Reset fixed positions
  nodes.forEach(n => { if(n.id !== focusNodeId){ n.fx = n.fy = null; } });

  if (layoutMode === 'tiers') {
    computeYearLayout();
    yearLabelGroup.style('display', null);
    nodes.forEach(n => {
      n.fx = n.x;
      n.fy = n.y;
    });
    ticked();
  } else if (layoutMode === 'force') {
    simulation.force('tier', null); // Remove tier force if exists
    yearLabelGroup.style('display', 'none');
    simulation.alpha(1).restart();
  }
}


function highlightSearch(){
  const term = searchInput.value.trim().toLowerCase();
  nodeSel.classed('search-match', d => term !== '' && d.name.toLowerCase().includes(term));
}

function updateHiddenEdges(){
  const disp = new Map();
  nodeSel.each(function(d){
    disp.set(d.id, this.style.display);
  });
  const vis = d => (disp.get(d.id1)==='none' || disp.get(d.id2)==='none') ? 'none' : null;
  linkSel.style('display', vis);
  labelSel.style('display', vis);
  linkHitSel.style('display', vis);
}

function applyYearFilter(){
  if(!yearSlider.noUiSlider) return;
  const [minYear, maxYear] = yearSlider.noUiSlider.get().map(v => parseInt(v));
  nodeSel.style('display', d => {
    const y = parseInt(d.birth_year, 10);
    if (isNaN(y)) return null;
    return (y >= minYear && y <= maxYear) ? null : 'none';
  });
  updateHiddenEdges();
}

function updateHash(){
  const params = new URLSearchParams(location.hash.slice(1));
  if(focusNodeId !== null){
    params.set('focus', focusNodeId);
    params.set('depth', focusDepth);
  } else {
    params.delete('focus');
    params.delete('depth');
  }
  history.replaceState(null, '', '#'+params.toString());
}

function applyFocusFilter(restartSim = true){
  if(focusNodeId === null){
    nodeSel.style('display', null);
    nodeSel.classed('focus-node', false);
    visibleLinks = links.slice();
    refreshLinks(restartSim);
    linkSel.classed('focus-edge', false);
    updateHiddenEdges();
    return;
  }
  const depth = focusDepth;
  const vis = new Set([focusNodeId]);
  let frontier = [focusNodeId];
  for(let i=0;i<depth;i++){
    const next = [];
    frontier.forEach(id => {
      links.forEach(l => {
        if(l.id1===id || l.id2===id){
          const other = l.id1===id ? l.id2 : l.id1;
          if(!vis.has(other)){
            vis.add(other);
            next.push(other);
          }
        }
      });
    });
    frontier = next;
  }
  nodeSel.style('display', d => vis.has(d.id) ? null : 'none');
  nodeSel.classed('focus-node', d => d.id === focusNodeId);
  visibleLinks = links.filter(l => vis.has(l.id1) && vis.has(l.id2));
  refreshLinks(restartSim);
  linkSel.classed('focus-edge', d => d.id1===focusNodeId || d.id2===focusNodeId);
  updateHiddenEdges();
  focusRange.value = depth;
  focusNum.textContent = depth;
}

function setupSearchAndFilter(){
  const years = nodes.map(n => parseInt(n.birth_year, 10)).filter(y => !isNaN(y));
  if(years.length){
    const minY = Math.min(...years);
    const maxY = Math.max(...years);
    noUiSlider.create(yearSlider, {
      start:[minY, maxY],
      connect:true,
      step:1,
      range:{min:minY, max:maxY},
      tooltips:true,
      format:{to:v=>Math.round(v), from:v=>+v}
    });
    yearSlider.noUiSlider.on('update', applyYearFilter);
  } else {
    yearSlider.style.display = 'none';
  }
  searchInput.addEventListener('input', highlightSearch);
  focusRange.addEventListener('input', () => {
    focusDepth = parseInt(focusRange.value,10);
    focusNum.textContent = focusRange.value;
    if(focusNodeId !== null){
      applyFocusFilter();
      updateHash();
    }
  });
}

function refreshLinks(restartSim = true){
  const simLinks = buildSimLinks(visibleLinks);

  linkSel = linkGroup.selectAll('path.link').data(simLinks, d => links.indexOf(d.link))
        .join(
                enter => enter.append('path')
                                          .attr('class','link')
                                          .attr('stroke','#555')
                                          .attr('stroke-width',1.5)
                                          .attr('marker-end','url(#arrow)')
                                          .on('click', edgeMenu),
                update => update
                                          .attr('stroke','#555')          // keep base look identical
                                          .attr('stroke-width',1.5)
                                          .attr('marker-end','url(#arrow)')
                                          .on('click', edgeMenu),
                exit   => exit.remove()
          );

  linkHitSel = linkGroup.selectAll('path.link-hit').data(simLinks, d => links.indexOf(d.link))
        .join(
                enter => enter.append('path')
                                          .attr('class','link-hit')
                                          .on('click', edgeMenu),
                update => update.on('click', edgeMenu),
                exit   => exit.remove()
          );

  labelSel = linkGroup.selectAll('text.label').data(simLinks, d => links.indexOf(d.link))
  .join(
    enter => enter.append('text')
                  .attr('class','label')
                  .text(d => d.label)
                  /* dbl-click label edit */
                  .on('dblclick', (event,d) => {
                    event.stopPropagation();
                    openEdgePopup(d.link, event.pageX, event.pageY);
                  })
                  .on('click', edgeMenu),
    update => update.text(d => d.label),
    exit   => exit.remove()
  );

  simulation.force('link').links(simLinks);
  if (restartSim) {
    applyLayoutForces();
    if (layoutMode === 'force') {
      simulation.alpha(0.6).restart();
    } else {
      ticked();
    }
  } else {
    ticked();
  }
}

function updateHiddenEdges(){
  const disp = new Map();
  nodeSel.each(function(d){
    disp.set(d.id, this.style.display === 'none');
  });
  visibleLinks = links.filter(l => !disp.get(l.id1) && !disp.get(l.id2));
  refreshLinks();
}

function applyYearFilter(){
  if(!yearSlider.noUiSlider) return;
  const [minYear, maxYear] = yearSlider.noUiSlider.get().map(v => parseInt(v));
  nodeSel.style('display', d => {
    const y = parseInt(d.birth_year, 10);
    if (isNaN(y)) return null;
    return (y >= minYear && y <= maxYear) ? null : 'none';
  });
  updateHiddenEdges();
}

function setupSearchAndFilter(){
  const years = nodes.map(n => parseInt(n.birth_year, 10)).filter(y => !isNaN(y));
  if(years.length){
    const minY = Math.min(...years);
    const maxY = Math.max(...years);
    noUiSlider.create(yearSlider, {
      start:[minY, maxY],
      connect:true,
      step:1,
      range:{min:minY, max:maxY},
      tooltips:true,
      format:{to:v=>Math.round(v), from:v=>+v}
    });
    yearSlider.noUiSlider.on('update', applyYearFilter);
  } else {
    yearSlider.style.display = 'none';
  }
  searchInput.addEventListener('input', highlightSearch);
  focusRange.addEventListener('input', () => {
    focusDepth = parseInt(focusRange.value,10);
    focusNum.textContent = focusRange.value;
    if(focusNodeId !== null){
      applyFocusFilter();
      updateHash();
    }
  });
}

function updateGraph(skipSelectUpdate = false, highlightIdx = null, markDirty = true) {
  visibleLinks = links.slice();
  refreshLinks();

  /* ---- nodes ---- */
nodeSel = g.selectAll('.node').data(nodes, d => d.id)
  .join(
    enter => {
      const nodeG = enter.append('g').attr('class', 'node')
          .on('click', (event,d) => {
            event.stopPropagation();
            openNodePopup(d.id, event.pageX, event.pageY);
          })
          .on('dblclick', (event,d)=>{
            event.stopPropagation();
            if(focusNodeId === d.id){
              focusNodeId = null;
              focusBox.style.display = 'none';
              d.fx = null; d.fy = null;
            }else{
              focusNodeId = d.id;
              focusLabel.textContent = 'Focus: '+d.name;
              focusBox.style.display = 'flex';
              d.fx = d.x; d.fy = d.y;
            }
            applyFocusFilter();
            updateHash();
          })
          .call(d3.drag().on('start', dragstarted)
                        .on('drag',  dragged)
                        .on('end',   dragended));

      nodeG.append('circle').attr('r', 22);
      nodeG.append('image')
           .attr('class','node-image')
           .attr('clip-path','url(#nodeClip)')
           .attr('x',-22)
           .attr('y',-22)
           .attr('width',44)
           .attr('height',44)
           .attr('href', d => d.image || '')
           .style('display', d => d.image ? null : 'none');
      nodeG.append('text')
           .attr('dominant-baseline', 'central')
           .text(d => formatNodeLabel(d));
      return nodeG;
    },
    update => update.each(function(d){
      const n = d3.select(this);
      n.on('click', (event)=>{
        event.stopPropagation();
        openNodePopup(d.id, event.pageX, event.pageY);
      })
      .on('dblclick', (event)=>{
        event.stopPropagation();
        if(focusNodeId === d.id){
          focusNodeId = null;
          focusBox.style.display = 'none';
          d.fx = null; d.fy = null;
        }else{
          focusNodeId = d.id;
          focusLabel.textContent = 'Focus: '+d.name;
          focusBox.style.display = 'flex';
          d.fx = d.x; d.fy = d.y;
        }
        applyFocusFilter();
        updateHash();
      });
      n.select('text').text(formatNodeLabel(d));
      n.select('image.node-image')
        .attr('href', d.image || '')
        .style('display', d.image ? null : 'none')
        .attr('clip-path','url(#nodeClip)');
    }),
    exit   => exit.remove()
  );

  simulation.nodes(nodes);
  applyLayoutForces();
  if (layoutMode === 'force') {
    simulation.alpha(0.6).restart();
  } else {
    ticked();
  }

  if (!skipSelectUpdate) populateSelects();
  if (highlightIdx !== null) {
    linkSel.filter(d => links.indexOf(d.link) === highlightIdx)
           .classed('highlight', true)
           .transition().delay(10000)
           .on('end', function () { d3.select(this).classed('highlight', false); });
  }
  refreshExport(markDirty);
  applyFocusFilter();
  applyYearFilter();
  highlightSearch();
}


function openEdgePopup(linkObj, x, y) {
  edgePopupLink = linkObj;
  edgePopupLabel.value = linkObj.label || '';
  edgePopup.style.left = (x + 5) + 'px';
  edgePopup.style.top  = (y + 5) + 'px';
  edgePopup.style.display = 'block';
}

function edgeMenu(event, d) {
  if (event.detail > 1) return; // ignore double-click
  event.stopPropagation();
  if (!d || !d.link) return;
  openEdgePopup(d.link, event.pageX, event.pageY);
}

function hideEdgePopup() {
  edgePopup.style.display = 'none';
  edgePopupLink = null;
}

function deleteImageFile(id, path){
  fetch('/delete_image', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ node_id: id, image: path })
  });
}

function renderNodeImages(n){
  nodePopupImages.innerHTML = '';
  (n.images || []).forEach((src, idx) => {
    const wrap = document.createElement('div');
    wrap.className = 'item';
    const img = document.createElement('img');
    img.src = src;
    wrap.appendChild(img);
    const actions = document.createElement('div');
    actions.className = 'actions';
    const left = document.createElement('button');
    left.textContent = '\u25C0';
    left.addEventListener('click', () => moveImage(idx,-1));
    const right = document.createElement('button');
    right.textContent = '\u25B6';
    right.addEventListener('click', () => moveImage(idx,1));
    const del = document.createElement('button');
    del.textContent = 'X';
    del.addEventListener('click', () => removeImage(idx));
    actions.appendChild(left);
    actions.appendChild(right);
    actions.appendChild(del);
    wrap.appendChild(actions);
    nodePopupImages.appendChild(wrap);
  });
}

function moveImage(idx, delta){
  const n = nodeById.get(nodePopupId);
  if(!n) return;
  const imgs = n.images;
  const newIdx = idx + delta;
  if(newIdx < 0 || newIdx >= imgs.length) return;
  [imgs[idx], imgs[newIdx]] = [imgs[newIdx], imgs[idx]];
  n.image = imgs[0] || null;
  renderNodeImages(n);
  updateGraph();
}

function removeImage(idx){
  const n = nodeById.get(nodePopupId);
  if(!n) return;
  const [img] = n.images.splice(idx,1);
  deleteImageFile(n.id, img);
  n.image = n.images[0] || null;
  renderNodeImages(n);
  updateGraph();
}

async function dedupeImages(n){
  const hashes = new Map();
  for(let i=0;i<n.images.length;i++){
    const src = n.images[i];
    try{
      const ab = await fetch(src).then(r=>r.arrayBuffer());
      const hashBuf = await crypto.subtle.digest('SHA-256', ab);
      const hash = Array.from(new Uint8Array(hashBuf)).map(b=>b.toString(16).padStart(2,'0')).join('');
      if(hashes.has(hash)){
        deleteImageFile(n.id, src);
        n.images.splice(i,1);
        i--;
      }else{
        hashes.set(hash, src);
      }
    }catch(e){console.error(e);}
  }
  n.image = n.images[0] || null;
}

function openNodePopup(id, x, y) {
  const n = nodeById.get(id);
  if (!n) return;
  nodePopupId = id;
  nodePopupImages.innerHTML = '';
  nodePopupName.value = n.name || '';
  nodePopupYear.value = n.birth_year || '';
  const curId = id;
  dedupeImages(n).then(()=>{
    if(nodePopupId === curId){
      renderNodeImages(n);
    }
  });
  nodePopup.style.left = (x + 5) + 'px';
  nodePopup.style.top  = (y + 5) + 'px';
  nodePopup.style.display = 'block';
  nodePopupName.focus();
}

function hideNodePopup() {
  nodePopup.style.display = 'none';
  nodePopupId = null;
}

nodePopupSave.addEventListener('click', e => {
  e.stopPropagation();
  if (nodePopupId === null) return;
  const n = nodeById.get(nodePopupId);
  n.name = nodePopupName.value.trim() || n.name;
  const year = nodePopupYear.value.trim();
  if (year === '') delete n.birth_year; else n.birth_year = year;
  hideNodePopup();
  populateSelects();
  updateGraph();
});

nodePopupDelete.addEventListener('click', e => {
  e.stopPropagation();
  if (nodePopupId === null) return;
  const id = nodePopupId;
  const idx = nodes.findIndex(n=>n.id===id);
  if (idx !== -1) nodes.splice(idx,1);
  links = links.filter(l=>l.id1!==id && l.id2!==id);
  nodeById.delete(id);
  hideNodePopup();
  populateSelects();
  updateGraph();
});

nodePopupClose.addEventListener('click', e => {
  e.stopPropagation();
  hideNodePopup();
});

edgePopupSave.addEventListener('click', e => {
  e.stopPropagation();
  if (!edgePopupLink) return;
  edgePopupLink.label = edgePopupLabel.value;
  hideEdgePopup();
  updateGraph();
});
edgePopupReverse.addEventListener('click', e => {
  e.stopPropagation();
  if (!edgePopupLink) return;
  const l = edgePopupLink;
  [l.id1, l.id2] = [l.id2, l.id1];
  hideEdgePopup();
  if(focusNodeId !== null){
    applyFocusFilter(false);
  }else{
    refreshLinks(false);
    updateHiddenEdges();
  }
  refreshExport();
});
edgePopupDelete.addEventListener('click', e => {
  e.stopPropagation();
  if (!edgePopupLink) return;
  const idx = links.indexOf(edgePopupLink);
  if (idx !== -1) links.splice(idx, 1);
  hideEdgePopup();
  updateGraph();
});
edgePopupClose.addEventListener('click', e => {
  e.stopPropagation();
  hideEdgePopup();
});
document.body.addEventListener('click', e => {
  if (!edgePopup.contains(e.target)) hideEdgePopup();
  if (!nodePopup.contains(e.target)) hideNodePopup();
});


/* ---------- drag handlers ---------- */
function dragstarted(event,d){
  if(layoutMode === 'force'){
    if(d.id === focusNodeId) return;  // keep focus node immovable
    if(!event.active) simulation.alphaTarget(0.3).restart();
    d.fx=d.x; d.fy=d.y;
  }
}
function dragged(event,d){
  if(layoutMode === 'force'){
    if(d.id === focusNodeId) return;  // ignore drags on focus node
    d.fx=event.x; d.fy=event.y;
  } else {
    if(d.id === focusNodeId) return;
    d.x = event.x; d.y = event.y;
    ticked();
  }
}
function dragended(event,d){
  if(layoutMode === 'force'){
    if(d.id === focusNodeId) return;  // remain fixed when focused
    if(!event.active) simulation.alphaTarget(0);
    d.fx=null; d.fy=null;
  } else {
    if(d.id === focusNodeId) return;
    ticked();
  }
}

/* ---------- UI events ---------- */
document.getElementById('perturb').addEventListener('click',()=>{
  nodes.forEach(n=>{
    n.x += (Math.random()-0.5)*40;
    n.y += (Math.random()-0.5)*40;
  });
  if (layoutMode === 'force') {
    simulation.alpha(0.8).restart();
  } else {
    ticked();
  }
});

document.getElementById('dampen').addEventListener('click',()=>{
  nodes.forEach(n=>{
    n.vx = (n.vx || 0) * 0.5;
    n.vy = (n.vy || 0) * 0.5;
  });
});

chargeInput.addEventListener('input', e=>{
  simulation.force('charge').strength(+e.target.value);
  if (layoutMode === 'force') {
    simulation.alpha(0.8).restart();
  } else {
    ticked();
  }
});

linkInput.addEventListener('input', e=>{
  simulation.force('link').distance(+e.target.value);
  if (layoutMode === 'force') {
    simulation.alpha(0.8).restart();
  } else {
    ticked();
  }
});

layoutSelect.addEventListener('change', e => {
  layoutMode = e.target.value;
  applyLayoutForces();
});

document.addEventListener('paste', e => {
  if(nodePopupId === null) return;
  const item = Array.from(e.clipboardData.items).find(i=>i.type.startsWith('image/'));
  if(!item) return;
  const file = item.getAsFile();
  uploadImage(nodePopupId, file);
});

function uploadImage(id, file){
  const fd = new FormData();
  fd.append('node_id', id);
  fd.append('image', file, file.name || 'clipboard.png');
  fetch('/upload', {method:'POST', body:fd})
    .then(r => r.ok ? r.text() : Promise.reject())
    .then(resp => {
      if(resp === 'DUPLICATE') return;
      const n = nodeById.get(id);
      if(!n.images) n.images = [];
      n.images.push(`images/${resp}`);
      n.image = n.images[0] || null;
      dedupeImages(n).then(()=>{
        updateGraph();
        if(nodePopupId === id){
          renderNodeImages(n);
        }
      });
    });
}

/* add node */
function addNode() {
  const inp      = document.getElementById('newNodeName');
  const yearInp  = document.getElementById('newNodeYear');
  const name     = inp.value.trim();
  const year     = yearInp.value.trim();
  if (!name) return;

  const id = nextNodeId++;
  const obj = { id, name };
  if (year !== '') obj.birth_year = year;
  nodes.push(obj);
  nodeById.set(id, nodes[nodes.length - 1]);

  const fromVal  = edgeFrom.value;   // preserve current "from" selection
  const labelVal = edgeLabel.value;  // preserve label text

  inp.value = '';
  yearInp.value = '';

  updateGraph(true);                 // refresh layout only
  populateSelects();                 // now update dropdowns

  edgeFrom.value = fromVal;          // restore previous "from" selection
  edgeTo.value   = id;               // default "to" to newly added node
  edgeLabel.value = labelVal;        // restore label text
}

document.getElementById('addNodeBtn').addEventListener('click', addNode);
document.getElementById('newNodeName').addEventListener('keydown', e => {
  if (e.key === 'Enter') addNode();
});
document.getElementById('newNodeYear').addEventListener('keydown', e => {
  if (e.key === 'Enter') addNode();
});

/* add edge */
addEdgeBtn.addEventListener('click', () => {
  const id1 = parseInt(edgeFrom.value, 10);
  const id2 = parseInt(edgeTo.value,   10);
  const lbl = edgeLabel.value.trim() || '';

  if (isNaN(id1) || isNaN(id2) || id1 === id2) return;
  links.push({ id1, id2, label: lbl });
  edgeLabel.value = '';
  updateGraph(true, links.length - 1);   // skip select refresh, highlight new link
});

/* ---------- initial render ---------- */
loadData().then(() => {
  const params = new URLSearchParams(location.hash.slice(1));
  if(params.has('focus')){
    focusNodeId = parseInt(params.get('focus'),10);
    focusDepth = parseInt(params.get('depth') || '1',10);
    focusRange.value = focusDepth;
    focusNum.textContent = focusDepth;
    const n = nodeById.get(focusNodeId);
    if(n){
      focusLabel.textContent = 'Focus: ' + n.name;
      focusBox.style.display = 'flex';
    }
  }
  populateSelects();
  setupSearchAndFilter();
  updateGraph(false, null, false);
  if(focusNodeId !== null){
    applyFocusFilter();
  }
});

// Add this code AFTER populateSelects() is called in your initialization
// This is the simple, standard way to focus the search field when dropdown opens
$(document).on('select2:open', function() {
  document.querySelector('.select2-container--open .select2-search__field').focus();
});
</script>
</body>
</html>
