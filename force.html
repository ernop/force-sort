<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Force‑Directed People Graph</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/css/select2.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.full.min.js"></script>
  <style>
    html,body{margin:0;height:100%;background:#fff;font-family:Arial,Helvetica,sans-serif}
    #topControls,#bottomControls{display:flex;gap:12px;padding:8px;flex-wrap:wrap}
    #topControls{border-bottom:1px solid #ddd}
    #bottomControls{border-top:1px solid #ddd}
    #graph{width:100%;height:calc(100% - 260px)} /* two control bars + export */

    textarea#export{position:fixed;bottom:0;left:0;width:100%;height:140px;border:none;resize:none;font-family:monospace;padding:8px;box-sizing:border-box;background:#f8f8f8}
    textarea#export.unsaved{background:#fff3c4}

    .node circle{fill:#a7d3ff;stroke:#fff;stroke-width:2px;cursor:grab}
    
    .link{stroke:#555;stroke-width:1.5px;fill:none;marker-end:url(#arrow)}
    .link.highlight{stroke:red;stroke-width:3px}
    text{font-size:12px;pointer-events:none;fill:#000}
    .label{pointer-events:all;cursor:pointer}
    .link-hit{stroke:transparent;stroke-width:14px;fill:none;cursor:pointer}
    button{cursor:pointer}
    #edgePopup{position:absolute;background:#ffffe0;border:1px solid #aaa;border-radius:4px;padding:4px;font-size:12px;box-shadow:0 2px 4px rgba(0,0,0,0.2);display:none}
    #edgePopup input{width:120px}
    #edgePopup .actions{display:flex;gap:4px;margin-top:4px}
    
    /* bigger add buttons */
    #addNodeBtn,#addEdgeBtn{font-size:16px;padding:6px 12px}

    #layoutLabel{margin-left:auto}
  </style>
</head>
<body>
  <!-- top toolbar -->
  <div id="topControls">
    <button id="perturb">Perturb</button>
    <button id="dampen">Remove Momentum</button>
    <label>Charge <input id="chargeRange" type="range" min="-1000" max="0" value="-300"></label>
    <label>Link&nbsp;Dist <input id="linkRange" type="range" min="30" max="300" value="150"></label>
    <label id="layoutLabel">Layout
      <select id="layoutSelect">
        <option value="force">Force</option>
        <option value="tiers">Tiers</option>
      </select>
    </label>
  </div>

  <!-- graph area -->
  <div id="graph"></div>

  <!-- bottom toolbar -->
<div id="bottomControls">
  <label>Add Node
    <input id="newNodeName" type="text" placeholder="Name">
    <input id="newNodeYear" type="text" placeholder="Birth Year">
    <button id="addNodeBtn">Add</button>
  </label>
  <label>Add Edge from
    <select id="edgeFrom"></select> to
    <select id="edgeTo"></select> label
    <input id="edgeLabel" type="text" placeholder="Label" list="presetLabels">
    <button id="addEdgeBtn">Add</button>
  </label>
  <datalist id="presetLabels">
    <option value="read">
    <option value="liked">
    <option value="inspired by">
    <option value="friend">
  </datalist>
</div>

  <!-- export area -->
  <textarea id="export" readonly></textarea>

  <!-- edge action popup -->
  <div id="edgePopup">
    <input id="edgePopupLabel" type="text">
    <div class="actions">
      <button id="edgePopupSave">Save</button>
      <button id="edgePopupReverse">Reverse</button>
      <button id="edgePopupDelete">Delete</button>
      <button id="edgePopupClose">X</button>
    </div>
  </div>

<script>
/* ---------- data loading ---------- */
/*
  data.json format:
  {
    "nodes": [{"id":1,"name":"Name"}],
    "links": [{"id1":1,"id2":2,"label":"label"}]
  }
*/
let nodes = [];
let links = [];
const nodeById = new Map();
let nextNodeId = 1;
function loadData(){
  return fetch("data.json")
    .then(r=>r.json())
    .then(data=>{
      nodes = data.nodes || [];
      links = data.links || [];
      nodes.forEach(n=>nodeById.set(n.id,n));
      nextNodeId = Math.max(0,...nodes.map(n=>n.id)) + 1;
    });
}

function buildSimLinks() {
  return links.map(e => ({
    source : nodeById.get(e.id1),
    target : nodeById.get(e.id2),
    label  : e.label,
    dir    : e.id1 < e.id2 ? 1 : -1    // A→B “up”, B→A “down”
  }));
}

/* ---------- SVG & defs ---------- */
const graphDiv = document.getElementById('graph');
const width    = graphDiv.clientWidth;
const height   = graphDiv.clientHeight;

const svg = d3.select(graphDiv).append('svg')
              .attr('width',width)
              .attr('height',height);

/* ---------- zoom & pan ---------- */
const zoom = d3.zoom()
  .scaleExtent([0.1, 4])                     // min / max zoom
  .on('zoom', event => g.attr('transform', event.transform));

svg.call(zoom).on('dblclick.zoom', null);     // disable dblclick-to-zoom

svg.append('defs').append('marker')
   .attr('id','arrow')
   .attr('viewBox','0 -5 10 10')
   .attr('refX',32).attr('refY',0) /* offset beyond circle */
   .attr('markerWidth',8).attr('markerHeight',8)
   .attr('orient','auto')
   .append('path').attr('d','M0,-5L10,0L0,5').attr('fill','#555');

const g = svg.append('g');
const linkGroup = g.append('g').attr('class','links');
let  linkSel     = linkGroup.selectAll('path.link');
let  linkHitSel  = linkGroup.selectAll('path.link-hit');
let  labelSel    = linkGroup.selectAll('text.label');
let  nodeSel     = g.selectAll('.node');

const BASE_COLLISION  = 40;  // default collision distance
const LABEL_OFFSET    = 6;   // px text sits beyond circle

/* ---------- D3 forces ---------- */
const chargeInput = document.getElementById('chargeRange');
const linkInput   = document.getElementById('linkRange');
const layoutSelect= document.getElementById('layoutSelect');
let   layoutMode  = layoutSelect.value;
const tierSpacing = 100;
const exportArea  = document.getElementById('export');   // ← new
const edgePopup       = document.getElementById('edgePopup');
const edgePopupLabel  = document.getElementById('edgePopupLabel');
const edgePopupSave   = document.getElementById('edgePopupSave');
const edgePopupReverse= document.getElementById('edgePopupReverse');
const edgePopupDelete = document.getElementById('edgePopupDelete');
const edgePopupClose  = document.getElementById('edgePopupClose');
let   edgePopupIndex  = null;

const simulation = d3.forceSimulation(nodes)
  .force('link',
         d3.forceLink()                       // links injected later
           .id(d => d.id)
           .distance(() => +linkRange.value))
  .force('charge',
         d3.forceManyBody()
           .strength(() => +chargeRange.value)        // live-updates with slider
           .distanceMax(1_000000))                       // repulse across whole graph
  .force('center', d3.forceCenter(width / 2, height / 2))
  .force('collision', d3.forceCollide().radius(BASE_COLLISION))
  .alphaDecay(0.001)                                  // cools more slowly → runs longer
  .on('tick', ticked);

function ticked(){
  /* ---------- arrow path ---------- */

  const pathD = d => {
    const dx   = d.target.x - d.source.x,
          dy   = d.target.y - d.source.y,
          dist = Math.hypot(dx, dy) || 1,
          r1   = d.source.radius,
          r2   = d.target.radius,
          tStart = r1 / dist,
          tEnd   = (dist - r2) / dist;  // line ends at target circle

    return `M${d.source.x + dx*tStart},${d.source.y + dy*tStart}L${d.source.x + dx*tEnd},${d.source.y + dy*tEnd}`;
  };

  linkSel.attr('d', pathD);
  linkHitSel.attr('d', pathD);

  /* keep nodes visible & movable */
  nodeSel.attr('transform', d => `translate(${d.x},${d.y})`);
  
	/* ---------- node name “radial-slot” positioning ---------- */
// gather incident edge angles for each node this tick
const incident = new Map();  // node.id → [angles]

links.forEach(l => {
  const src = nodeById.get(l.id1),
        tgt = nodeById.get(l.id2);
  if (!src || !tgt) return;

  const a = Math.atan2(tgt.y - src.y, tgt.x - src.x);   // angle src→tgt
  (incident.get(src.id) || incident.set(src.id, []).get(src.id)).push(a);
  (incident.get(tgt.id) || incident.set(tgt.id, []).get(tgt.id)).push(a + Math.PI); // opposite at tgt
});

// eight slot angles (0°,45°,…)
const slots       = Array.from({length:8}, (_,i)=>i*Math.PI/4);

nodeSel.select('text').each(function(d){
  const edges = incident.get(d.id) || [];
  // choose slot farthest from every incident edge
  let bestAng = 0, bestScore = -1;
  slots.forEach(s => {
    const score = edges.length
      ? Math.min(...edges.map(e => Math.abs(Math.atan2(Math.sin(s-e), Math.cos(s-e)))))
      : Math.PI;  // isolated node
    if (score > bestScore){ bestScore = score; bestAng = s; }
  });

  const rLab = (d.radius) + LABEL_OFFSET;
  const tx = Math.cos(bestAng) * rLab,
        ty = Math.sin(bestAng) * rLab;

  d3.select(this)
    .attr('x', tx)
    .attr('y', ty)
    .attr('dominant-baseline', 'central')
    .attr('text-anchor',
          Math.abs(Math.cos(bestAng)) < 0.3 ? 'middle' :
          (Math.cos(bestAng) > 0 ? 'start' : 'end'));
});
	
  /* ---------- label position ---------- */
  const delta     = 10;   // perpendicular offset (px)
  const fracToTgt = 0.65; // label sits 65 % toward target, just behind arrow

  labelSel.each(function (d) {
    /* use lower-ID → higher-ID to define perpendicular direction */
    const forward = d.source.id < d.target.id;
    const s       = forward ? d.source : d.target;
    const t       = forward ? d.target : d.source;
    const dx      = t.x - s.x,
          dy      = t.y - s.y,
          dist    = Math.hypot(dx, dy) || 1,
          px      = -dy / dist,            // unit perpendicular
          py      =  dx / dist,
          dir     = forward ? 1 : -1;      // “up” or “down”

    const lx = d.source.x + (d.target.x - d.source.x) * fracToTgt;
    const ly = d.source.y + (d.target.y - d.source.y) * fracToTgt;

    d.cx = lx + delta * px * dir;
    d.cy = ly + delta * py * dir;
  })
  .attr('x', d => d.cx)
  .attr('y', d => d.cy)
  .attr('text-anchor', 'middle')
  .attr('dominant-baseline', 'central')
  .attr('transform', d => {
    let ang = Math.atan2(d.target.y - d.source.y,
                         d.target.x - d.source.x) * 180 / Math.PI;
    if (ang > 90 || ang < -90) ang += 180;   // keep text upright
    return `rotate(${ang},${d.cx},${d.cy})`;
  });
}

/* ---------- helpers ---------- */

function updateNodeSizes() {
  const counts = new Map(nodes.map(n => [n.id, 0]));
  links.forEach(l => {
    counts.set(l.id1, (counts.get(l.id1) || 0) + 1);
    counts.set(l.id2, (counts.get(l.id2) || 0) + 1);
  });
  nodes.forEach(n => {
    n.radius    = 3;
    n.collision = BASE_COLLISION;
  });
  simulation.force('collision').radius(d => d.collision);
}

function formatNodeLabel(n){
  return (n.birth_year !== undefined && n.birth_year !== null && n.birth_year !== '')
         ? `${n.name} (${n.birth_year})`
         : n.name;
}

function populateSelects() {
  const sorted = nodes.slice().sort((a, b) => a.name.localeCompare(b.name));
  const opts = sorted
    .map(n => `<option value="${n.id}">${formatNodeLabel(n)}</option>`)
    .join('');

  const fromVal = edgeFrom.value;
  const toVal   = edgeTo.value;

  $(edgeFrom).html(opts);
  $(edgeTo).html(opts);

  $(edgeFrom).val(fromVal);
  $(edgeTo).val(toVal);

  if (!$(edgeFrom).hasClass('select2-hidden-accessible')) {
    $(edgeFrom).select2();
    $(edgeTo).select2();

    // open dropdown on focus for both keyboard and mouse
    $(edgeFrom).next('.select2').find('.select2-selection')
      .off('focus.open')
      .on('focus.open', () => $(edgeFrom).select2('open'));
    $(edgeTo).next('.select2').find('.select2-selection')
      .off('focus.open')
      .on('focus.open', () => $(edgeTo).select2('open'));

    $(edgeFrom)
      .off('focus.open')
      .on('focus.open', () => $(edgeFrom).select2('open'));
    $(edgeTo)
      .off('focus.open')
      .on('focus.open', () => $(edgeTo).select2('open'));

    // autofocus search field when dropdown opens
    const focusSearch = () =>
      setTimeout(() => {
        $('.select2-container--open .select2-search__field').last().trigger('focus');
      }, 0);

    $(edgeFrom)
      .off('select2:open')
      .on('select2:open', focusSearch);
    $(edgeTo)
      .off('select2:open')
      .on('select2:open', focusSearch);
  } else {
    $(edgeFrom).trigger('change.select2');
    $(edgeTo).trigger('change.select2');
  }
}


exportArea.addEventListener('click', () => {
  navigator.clipboard.writeText(exportArea.value)
    .then(() => exportArea.classList.remove('unsaved'));
});

function refreshExport() {
  exportArea.value = JSON.stringify({
    nodes: nodes.map(n => {
      const obj = { id: n.id, name: n.name };
      if (n.birth_year !== undefined && n.birth_year !== null && n.birth_year !== '') obj.birth_year = n.birth_year;
      return obj;
    }),
    links
  }, null, 2);
  exportArea.classList.add("unsaved");
}

function computeTiers() {
  const lvl = new Map(nodes.map(n => [n.id, 0]));
  for (let iter = 0; iter < nodes.length; iter++) {
    let changed = false;
    links.forEach(l => {
      const s = lvl.get(l.id1) || 0;
      const t = lvl.get(l.id2) || 0;
      if (t <= s) {
        lvl.set(l.id2, s + 1);
        changed = true;
      }
    });
    if (!changed) break;
  }
  nodes.forEach(n => n.tier = lvl.get(n.id) || 0);
}

function applyLayoutForces() {
  if (layoutMode === 'tiers') {
    computeTiers();
    simulation.force('tier', d3.forceY(d => d.tier * tierSpacing).strength(1));
  } else {
    simulation.force('tier', null);
  }
}

function updateGraph(skipSelectUpdate = false, highlightIdx = null) {
  updateNodeSizes();
  const simLinks = buildSimLinks();

  /* ---- links ---- */
  linkSel = linkGroup.selectAll('path.link').data(simLinks, (d,i)=>i)
        .join(
                enter => enter.append('path')
                                          .attr('class','link')
                                          .attr('stroke','#555')
                                          .attr('stroke-width',1.5)
                                          .attr('marker-end','url(#arrow)')
                                          .on('click', edgeMenu),
                update => update
                                          .attr('stroke','#555')          // keep base look identical
                                          .attr('stroke-width',1.5)
                                          .attr('marker-end','url(#arrow)')
                                          .on('click', edgeMenu),
                exit   => exit.remove()
          );

  linkHitSel = linkGroup.selectAll('path.link-hit').data(simLinks, (d,i)=>i)
        .join(
                enter => enter.append('path')
                                          .attr('class','link-hit')
                                          .on('click', edgeMenu),
                update => update.on('click', edgeMenu),
                exit   => exit.remove()
          );

  labelSel = linkGroup.selectAll('text.label').data(simLinks, (d,i)=>i)
  .join(
    enter => enter.append('text')
                  .attr('class','label')
                  .text(d => d.label)
                  /* dbl-click label edit */
                  .on('dblclick', (event,d) => {
                    event.stopPropagation();
                    const idx = labelSel.nodes().indexOf(event.currentTarget);
                    if (idx === -1) return;
                    openEdgePopup(idx, event.pageX, event.pageY);
                  })
                  .on('click', edgeMenu),
    update => update.text(d => d.label),
    exit   => exit.remove()
  );

  /* ---- nodes ---- */
nodeSel = g.selectAll('.node').data(nodes, d => d.id)
  .join(
    enter => {
      const nodeG = enter.append('g').attr('class', 'node')
          .call(d3.drag().on('start', dragstarted)
                        .on('drag',  dragged)
                        .on('end',   dragended))
          /* dbl-click name edit */
          .on('dblclick', (event,d) => {
            const newName = prompt('Rename node:', d.name || '');
            if (!newName) return;
            const newYear = prompt('Birth year (optional):', d.birth_year ?? '');
            d.name = newName;
            if (newYear === null || newYear.trim() === '') {
              delete d.birth_year;
            } else {
              d.birth_year = newYear.trim();
            }
            populateSelects();       // refresh dropdowns
            refreshExport();         // update code block
            d3.select(event.currentTarget).select('text').text(formatNodeLabel(d));
          });

      nodeG.append('circle').attr('r', d => d.radius);
      nodeG.append('text')
           .attr('dominant-baseline', 'central')
           .text(d => formatNodeLabel(d));
      return nodeG;
    },
    update => {
      update.select('text').text(d => formatNodeLabel(d));
      update.select('circle').attr('r', d => d.radius);
    },
    exit   => exit.remove()
  );

  simulation.nodes(nodes);
  simulation.force('link').links(simLinks);
  applyLayoutForces();
  simulation.alpha(0.6).restart();

  if (!skipSelectUpdate) populateSelects();
  if (highlightIdx !== null) {
    linkSel.filter((d, i) => i === highlightIdx)
           .classed('highlight', true)
           .transition().delay(10000)
           .on('end', function () { d3.select(this).classed('highlight', false); });
  }
  refreshExport();
}


function openEdgePopup(idx, x, y) {
  edgePopupIndex = idx;
  edgePopupLabel.value = links[idx].label || '';
  edgePopup.style.left = (x + 5) + 'px';
  edgePopup.style.top  = (y + 5) + 'px';
  edgePopup.style.display = 'block';
}

function edgeMenu(event, d) {
  if (event.detail > 1) return; // ignore double-click
  event.stopPropagation();
  let idx = linkSel.nodes().indexOf(event.currentTarget);
  if (idx === -1) idx = labelSel.nodes().indexOf(event.currentTarget);
  if (idx === -1) idx = linkHitSel.nodes().indexOf(event.currentTarget);
  if (idx === -1) return;

  openEdgePopup(idx, event.pageX, event.pageY);
}

function hideEdgePopup() {
  edgePopup.style.display = 'none';
  edgePopupIndex = null;
}

edgePopupSave.addEventListener('click', e => {
  e.stopPropagation();
  if (edgePopupIndex === null) return;
  links[edgePopupIndex].label = edgePopupLabel.value;
  hideEdgePopup();
  updateGraph();
});
edgePopupReverse.addEventListener('click', e => {
  e.stopPropagation();
  if (edgePopupIndex === null) return;
  const l = links[edgePopupIndex];
  [l.id1, l.id2] = [l.id2, l.id1];
  hideEdgePopup();
  updateGraph();
});
edgePopupDelete.addEventListener('click', e => {
  e.stopPropagation();
  if (edgePopupIndex === null) return;
  links.splice(edgePopupIndex, 1);
  hideEdgePopup();
  updateGraph();
});
edgePopupClose.addEventListener('click', e => {
  e.stopPropagation();
  hideEdgePopup();
});
document.body.addEventListener('click', e => {
  if (!edgePopup.contains(e.target)) hideEdgePopup();
});


/* ---------- drag handlers ---------- */
function dragstarted(event,d){
  if(!event.active) simulation.alphaTarget(0.3).restart();
  d.fx=d.x; d.fy=d.y;
}
function dragged(event,d){
  d.fx=event.x; d.fy=event.y;
}
function dragended(event,d){
  if(!event.active) simulation.alphaTarget(0);
  d.fx=null; d.fy=null;
}

/* ---------- UI events ---------- */
document.getElementById('perturb').addEventListener('click',()=>{
  nodes.forEach(n=>{
    n.x += (Math.random()-0.5)*40;
    n.y += (Math.random()-0.5)*40;
  });
  simulation.alpha(0.8).restart();
});

document.getElementById('dampen').addEventListener('click',()=>{
  nodes.forEach(n=>{
    n.vx = (n.vx || 0) * 0.5;
    n.vy = (n.vy || 0) * 0.5;
  });
});

chargeInput.addEventListener('input', e=>{
  simulation.force('charge').strength(+e.target.value);
  simulation.alpha(0.8).restart();
});

linkInput.addEventListener('input', e=>{
  simulation.force('link').distance(+e.target.value);
  simulation.alpha(0.8).restart();
});

layoutSelect.addEventListener('change', e => {
  layoutMode = e.target.value;
  applyLayoutForces();
  simulation.alpha(0.8).restart();
});

/* add node */
function addNode() {
  const inp      = document.getElementById('newNodeName');
  const yearInp  = document.getElementById('newNodeYear');
  const name     = inp.value.trim();
  const year     = yearInp.value.trim();
  if (!name) return;

  const id = nextNodeId++;
  const obj = { id, name };
  if (year !== '') obj.birth_year = year;
  nodes.push(obj);
  nodeById.set(id, nodes[nodes.length - 1]);

  const fromVal  = edgeFrom.value;   // preserve current "from" selection
  const labelVal = edgeLabel.value;  // preserve label text

  inp.value = '';
  yearInp.value = '';

  updateGraph(true);                 // refresh layout only
  populateSelects();                 // now update dropdowns

  edgeFrom.value = fromVal;          // restore previous "from" selection
  edgeTo.value   = id;               // default "to" to newly added node
  edgeLabel.value = labelVal;        // restore label text
}

document.getElementById('addNodeBtn').addEventListener('click', addNode);
document.getElementById('newNodeName').addEventListener('keydown', e => {
  if (e.key === 'Enter') addNode();
});
document.getElementById('newNodeYear').addEventListener('keydown', e => {
  if (e.key === 'Enter') addNode();
});

/* add edge */
addEdgeBtn.addEventListener('click', () => {
  const id1 = parseInt(edgeFrom.value, 10);
  const id2 = parseInt(edgeTo.value,   10);
  const lbl = edgeLabel.value.trim() || '';

  if (isNaN(id1) || isNaN(id2) || id1 === id2) return;
  links.push({ id1, id2, label: lbl });
  edgeLabel.value = '';
  updateGraph(true, links.length - 1);   // skip select refresh, highlight new link
});

/* ---------- initial render ---------- */
loadData().then(() => {
  populateSelects();
  updateGraph();
});
</script>
</body>
</html>
