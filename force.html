<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Forceâ€‘Directed People Graph</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/css/select2.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.full.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.js"></script>
  <style>
    html,body{margin:0;height:100%;background:#fff;font-family:Arial,Helvetica,sans-serif}
    #topControls,#bottomControls{display:flex;gap:12px;padding:8px;flex-wrap:wrap}
    #topControls{border-bottom:1px solid #ddd}
    #bottomControls{border-top:1px solid #ddd}
    #graph{width:100%;height:calc(100% - 120px)} /* two control bars */

    textarea#export{display:none}
    textarea#export.unsaved{background:#fff3c4}

    #searchBox{
      position:fixed;
      bottom:10px;
      right:10px;
      width:200px;
      display:flex;
      flex-direction:column;
      gap:8px;
      background:#fff;
      border:1px solid #ccc;
      padding:8px;
      box-shadow:0 2px 6px rgba(0,0,0,0.2);
      border-radius:4px;
     }
    #searchBox input{padding:4px;}
    #focusBox{
      position:fixed;
      bottom:10px;
      right:220px;
      width:200px;
      display:flex;
      flex-direction:column;
      gap:8px;
      background:#fff;
      border:1px solid #ccc;
      padding:8px;
      box-shadow:0 2px 6px rgba(0,0,0,0.2);
      border-radius:4px;
     }
    .node.search-match circle{stroke:#ff5722;stroke-width:4px;}
    .node.focus-node circle{stroke:#0a0;stroke-width:4px;}

    .node circle{fill:#a7d3ff;stroke:#fff;stroke-width:2px;cursor:grab}
    .node-image{pointer-events:none}
    .year-labels text{font-size:12px;fill:#888}
    
    .link{stroke:#555;stroke-width:1.5px;fill:none;marker-end:url(#arrow)}
    /* highlight lines thicker so search hits stand out */
    .link.highlight{stroke:red;stroke-width:6px}
    .link.focus-edge{stroke:#0a0;stroke-width:3px}
    
    text{font-size:12px;pointer-events:none;fill:#000}
    .label{pointer-events:all;cursor:pointer}
    .link-hit{stroke:transparent;stroke-width:14px;fill:none;cursor:pointer}
    button{cursor:pointer}
    /* keep year group headers visible without covering search field */
    .select2-results__group{position:sticky;bottom:0;background:#fff;margin-top:4px}
    #edgePopup{position:absolute;background:#ffffe0;border:1px solid #aaa;border-radius:4px;padding:4px;font-size:12px;box-shadow:0 2px 4px rgba(0,0,0,0.2);display:none}
    #edgePopup input{width:120px}
    #edgePopup .actions{display:flex;gap:4px;margin-top:4px}

    #nodePopup{position:absolute;background:#ffffe0;border:1px solid #aaa;border-radius:4px;padding:4px;font-size:12px;box-shadow:0 2px 4px rgba(0,0,0,0.2);display:none}
    #nodePopup input{width:120px;display:block;margin-top:4px}
    #nodePopup .actions{display:flex;gap:4px;margin-top:4px}
    #nodePopup .hint{font-style:italic;margin-top:4px;font-size:11px}
    #nodePopupImages{display:flex;flex-wrap:wrap;gap:4px;margin-top:4px}
    #nodePopupImages .item{position:relative}
    #nodePopupImages img{width:44px;height:44px;border:1px solid #ccc}
    #nodePopupImages .actions{position:absolute;top:0;right:0;display:flex;flex-direction:column}
    #nodePopupImages button{padding:0 2px;font-size:10px;background:#fff;border:1px solid #ccc;cursor:pointer}
    
    /* bigger add buttons */
    #addNodeBtn,#addEdgeBtn{font-size:16px;padding:6px 12px}

    #layoutLabel{margin-left:auto}
  </style>
</head>
<body>
  <div id="topControls">
    <button id="perturb">Perturb</button>
    <button id="dampen">Remove Momentum</button>
    <label>Charge <input id="chargeRange" type="range" min="-1000" max="0" value="-300"></label>
    <label>Link&nbsp;Dist <input id="linkRange" type="range" min="30" max="300" value="150"></label>
    <label id="layoutLabel">Layout
      <select id="layoutSelect">
        <option value="force">Force</option>
        <option value="tiers">Tiers</option>
      </select>
    </label>
  </div>

  <div id="graph"></div>

  <div id="bottomControls">
  <label>Add Node
    <input id="newNodeName" type="text" placeholder="Name">
    <input id="newNodeYear" type="text" placeholder="Birth Year">
    <button id="addNodeBtn">Add</button>
  </label>
  <label>Add Edge from
    <select id="edgeFrom"></select> to
    <select id="edgeTo"></select> label
    <input id="edgeLabel" type="text" placeholder="Label" list="presetLabels">
    <button id="addEdgeBtn">Add</button>
  </label>
  <datalist id="presetLabels">
    <option value="read">
    <option value="liked">
    <option value="inspired by">
    <option value="friend">
    </datalist>
</div>

  <div id="searchBox">
    <input id="searchInput" type="text" placeholder="search">
    <div id="yearSlider"></div>
  </div>
  <div id="focusBox" style="display:none">
    <div id="focusLabel"></div>
    <label>Focus Range:
      <input id="focusRange" type="range" min="1" max="5" value="1">
      <span id="focusNum">1</span>
    </label>
  </div>

  <textarea id="export" readonly></textarea>

  <div id="edgePopup">
    <input id="edgePopupLabel" type="text">
    <div class="actions">
      <button id="edgePopupSave">Save</button>
      <button id="edgePopupReverse">Reverse</button>
      <button id="edgePopupDelete">Delete</button>
      <button id="edgePopupClose">X</button>
    </div>
  </div>

  <div id="nodePopup">
    <input id="nodePopupName" type="text" placeholder="Name">
    <input id="nodePopupYear" type="text" placeholder="Birth Year">
    <div class="actions">
      <button id="nodePopupSave">Save</button>
      <button id="nodePopupDelete">Delete</button>
      <button id="nodePopupClose">X</button>
    </div>
    <div class="hint">Paste an image while this popup is open</div>
    <div id="nodePopupImages"></div>
  </div>

<script>
/* ---------- data loading ---------- */
let nodes = [];
let links = [];
let visibleLinks = []; // This will be dynamically set by applyAllFiltersAndRefresh
const nodeById = new Map();
let nextNodeId = 1;
// let focusNodeId = null; // REPLACED by currentFilters.focus.nodeId
// let focusDepth = 1; // REPLACED by currentFilters.focus.depth

// Centralized filter state
let currentFilters = {
    year: { min: null, max: null },
    focus: { nodeId: null, depth: 1 },
    searchTerm: ''
};

function loadData(){
  return fetch("data.json")
    .then(r=>r.json())
    .then(data=>{
      nodes = data.nodes || [];
      links = data.links || [];
      // visibleLinks = links.slice(); // No longer initialized here
      nodes.forEach(n=>{
        n.images = Array.isArray(n.images) ? n.images : [];
        n.image = n.images[0] || null;
        nodeById.set(n.id,n);
      });
      nextNodeId = Math.max(0,...nodes.map(n=>n.id)) + 1;
    });
}

function buildSimLinks(arr) {
  return arr.map(e => ({
    source : nodeById.get(e.id1),
    target : nodeById.get(e.id2),
    label  : e.label,
    dir    : e.id1 < e.id2 ? 1 : -1,
    link   : e
  }));
}

/* ---------- SVG & defs ---------- */
const graphDiv = document.getElementById('graph');
const width    = graphDiv.clientWidth;
const height   = graphDiv.clientHeight;

const svg = d3.select(graphDiv).append('svg')
              .attr('width',width)
              .attr('height',height);

/* ---------- zoom & pan ---------- */
const zoom = d3.zoom()
  .scaleExtent([0.1, 4])             
  .on('zoom', event => g.attr('transform', event.transform));

svg.call(zoom).on('dblclick.zoom', null);    // disable dblclick-to-zoom

const defs = svg.append('defs');
defs.append('marker')
  .attr('id','arrow')
  .attr('viewBox','0 -5 10 10')
  .attr('refX',32).attr('refY',0) /* offset beyond circle */
  .attr('markerWidth',8).attr('markerHeight',8)
  .attr('orient','auto')
  .append('path').attr('d','M0,-5L10,0L0,5').attr('fill','#555');

defs.append('clipPath')
    .attr('id','nodeClip')
    .append('circle')
    .attr('r',22);

const g = svg.append('g');
const linkGroup = g.append('g').attr('class','links');
let  linkSel     = linkGroup.selectAll('path.link');
let  linkHitSel  = linkGroup.selectAll('path.link-hit');
let  labelSel    = linkGroup.selectAll('text.label');
const yearLabelGroup = g.append('g').attr('class','year-labels').style('display','none');
let  yearLabelSel = yearLabelGroup.selectAll('text');
let  nodeSel     = g.selectAll('.node');

const BASE_COLLISION  = 40;
const LABEL_OFFSET    = 6;

/* ---------- D3 forces ---------- */
const chargeInput = document.getElementById('chargeRange');
const linkInput   = document.getElementById('linkRange');
const layoutSelect= document.getElementById('layoutSelect');
let   layoutMode  = layoutSelect.value;
const tierSpacing = 100;
const yearSpacing = 20;
const exportArea  = document.getElementById('export');
const searchInput  = document.getElementById('searchInput');
const yearSlider   = document.getElementById('yearSlider');
const edgePopup      = document.getElementById('edgePopup');
const edgePopupLabel = document.getElementById('edgePopupLabel');
const edgePopupSave  = document.getElementById('edgePopupSave');
const edgePopupReverse= document.getElementById('edgePopupReverse');
const edgePopupDelete = document.getElementById('edgePopupDelete');
const edgePopupClose  = document.getElementById('edgePopupClose');
let   edgePopupLink   = null;

const nodePopup      = document.getElementById('nodePopup');
const nodePopupName  = document.getElementById('nodePopupName');
const nodePopupYear  = document.getElementById('nodePopupYear');
const nodePopupSave  = document.getElementById('nodePopupSave');
const nodePopupDelete = document.getElementById('nodePopupDelete');
const nodePopupClose  = document.getElementById('nodePopupClose');
const nodePopupImages = document.getElementById('nodePopupImages');
const focusBox        = document.getElementById('focusBox');
const focusLabel      = document.getElementById('focusLabel');
const focusRange      = document.getElementById('focusRange');
const focusNum        = document.getElementById('focusNum');
let   nodePopupId     = null;

const simulation = d3.forceSimulation(nodes)
  .force('link',
         d3.forceLink()
           .id(d => d.id)
           .distance(() => +linkRange.value))
  .force('charge',
         d3.forceManyBody()
           .strength(() => +chargeRange.value)
           .distanceMax(1_000000))
  .force('center', d3.forceCenter(width / 2, height / 2))
  .force('collision', d3.forceCollide().radius(40))
  .alphaDecay(0.001)
  .on('tick', ticked);

function ticked(){
  const r = 22;
  const pathD = d => {
    const dx   = d.target.x - d.source.x,
          dy   = d.target.y - d.source.y,
          dist = Math.hypot(dx, dy) || 1,
          tEnd   = (dist - r) / dist;
    return `M${d.source.x},${d.source.y}L${d.source.x + dx*tEnd},${d.source.y + dy*tEnd}`;
  };

  linkSel.attr('d', pathD);
  linkHitSel.attr('d', pathD);
  nodeSel.attr('transform', d => `translate(${d.x},${d.y})`);
  
const incident = new Map();
(visibleLinks || []).forEach(l => { // Use global visibleLinks
  const src = nodeById.get(l.id1),
        tgt = nodeById.get(l.id2);
  if (!src || !tgt || !src.x || !tgt.x) return; // Ensure nodes and positions exist

  const a = Math.atan2(tgt.y - src.y, tgt.x - src.x);
  (incident.get(src.id) || incident.set(src.id, []).get(src.id)).push(a);
  (incident.get(tgt.id) || incident.set(tgt.id, []).get(tgt.id)).push(a + Math.PI);
});

const slots       = Array.from({length:8}, (_,i)=>i*Math.PI/4);
const labelRadius = 28;

nodeSel.select('text').each(function(d){
  const edges = incident.get(d.id) || [];
  let bestAng = 0, bestScore = -1;
  slots.forEach(s => {
    const score = edges.length
      ? Math.min(...edges.map(e => Math.abs(Math.atan2(Math.sin(s-e), Math.cos(s-e)))))
      : Math.PI;
    if (score > bestScore){ bestScore = score; bestAng = s; }
  });

  const tx = Math.cos(bestAng) * labelRadius,
        ty = Math.sin(bestAng) * labelRadius;

  d3.select(this)
    .attr('x', tx)
    .attr('y', ty)
    .attr('dominant-baseline', 'central')
    .attr('text-anchor',
          Math.abs(Math.cos(bestAng)) < 0.3 ? 'middle' :
          (Math.cos(bestAng) > 0 ? 'start' : 'end'));
});
    
  const delta     = 10;
  const fracToTgt = 0.65;

  labelSel.each(function (d) {
    if (!d.source || !d.target || typeof d.source.x === 'undefined' || typeof d.target.x === 'undefined') return;
    const forward = d.source.id < d.target.id;
    const s       = forward ? d.source : d.target;
    const t       = forward ? d.target : d.source;
    const dx      = t.x - s.x,
          dy      = t.y - s.y,
          dist    = Math.hypot(dx, dy) || 1,
          px      = -dy / dist,
          py      =  dx / dist,
          dir     = forward ? 1 : -1;

    const lx = d.source.x + (d.target.x - d.source.x) * fracToTgt;
    const ly = d.source.y + (d.target.y - d.source.y) * fracToTgt;

    d.cx = lx + delta * px * dir;
    d.cy = ly + delta * py * dir;
  })
  .attr('x', d => d.cx)
  .attr('y', d => d.cy)
  .attr('text-anchor', 'middle')
  .attr('dominant-baseline', 'central')
  .attr('transform', d => {
    if (!d.source || !d.target || typeof d.source.x === 'undefined' || typeof d.target.x === 'undefined') return '';
    let ang = Math.atan2(d.target.y - d.source.y,
                         d.target.x - d.source.x) * 180 / Math.PI;
    if (ang > 90 || ang < -90) ang += 180;
    return `rotate(${ang},${d.cx},${d.cy})`;
  });
}

/* ---------- helpers ---------- */
function formatNodeLabel(n){
  return (n.birth_year !== undefined && n.birth_year !== null && n.birth_year !== '')
         ? `${n.name} (${n.birth_year})`
         : n.name;
}

function populateSelects() {
  const groups = new Map();
  nodes.forEach(n => {
    const key = n.birth_year && n.birth_year !== '' ? n.birth_year : 'Unknown';
    if (!groups.has(key)) groups.set(key, []);
    groups.get(key).push(n);
  });
  const sortedYears = Array.from(groups.keys()).sort((a, b) => {
    const ay = a === 'Unknown' ? Infinity : parseInt(a, 10);
    const by = b === 'Unknown' ? Infinity : parseInt(b, 10);
    return ay - by;
  });

  const opts = sortedYears.map(y => {
    const items = groups.get(y).sort((a,b)=>a.name.localeCompare(b.name))
      .map(n => `<option value="${n.id}">${formatNodeLabel(n)}</option>`)
      .join('');
    return `<optgroup label="${y}">${items}</optgroup>`;
  }).join('');

  const fromVal = edgeFrom.value;
  const toVal = edgeTo.value;

  if ($(edgeFrom).hasClass('select2-hidden-accessible')) $(edgeFrom).select2('destroy');
  if ($(edgeTo).hasClass('select2-hidden-accessible')) $(edgeTo).select2('destroy');

  edgeFrom.innerHTML = opts;
  edgeTo.innerHTML = opts;
  $(edgeFrom).val(fromVal);
  $(edgeTo).val(toVal);

  const select2Options = { width: '200px', minimumResultsForSearch: 0 };
  $(edgeFrom).select2(select2Options);
  $(edgeTo).select2(select2Options);
}

exportArea.addEventListener('click', () => {
  navigator.clipboard.writeText(exportArea.value)
    .then(() => exportArea.classList.remove('unsaved'));
});

function saveDataToServer(text){
  fetch('/save_data', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: text
  });
}

function refreshExport(markDirty = true) {
  exportArea.value = JSON.stringify({
    nodes: nodes.map(n => {
      const obj = { id: n.id, name: n.name };
      if (n.birth_year !== undefined && n.birth_year !== null && n.birth_year !== '') obj.birth_year = n.birth_year;
      obj.images = n.images ? n.images.slice() : [];
      return obj;
    }),
    links
  }, null, 2);
  if (markDirty) {
    exportArea.classList.add('unsaved');
    saveDataToServer(exportArea.value);
  } else {
    exportArea.classList.remove('unsaved');
  }
}

function computeYearLayout() {
  const years = nodes
    .map(n => parseInt(n.birth_year, 10))
    .filter(y => !isNaN(y));
  let minYear, maxYear;
  if (years.length === 0) {
    minYear = maxYear = new Date().getFullYear();
  } else {
    minYear = Math.min(...years);
    maxYear = Math.max(...years);
  }

  const rows = new Map();
  nodes.forEach(n => {
    const y = parseInt(n.birth_year, 10);
    const key = isNaN(y) ? 'unknown' : y;
    if (!rows.has(key)) rows.set(key, []);
    rows.get(key).push(n);
  });

  rows.forEach((row, key) => {
    row.forEach((n, i) => {
      const yr = parseInt(n.birth_year, 10);
      const line = isNaN(yr) ? maxYear + 1 : yr;
      n.x = 100 + i * 150; // Preserve original x for tiers calculation
      n.y = (line - minYear) * yearSpacing + 40; // Preserve original y
    });
  });

  const labelData = Array.from(rows.keys()).map(k => ({
    key: k,
    line: isNaN(parseInt(k,10)) ? maxYear + 1 : parseInt(k,10)
  }));
  yearLabelSel = yearLabelGroup.selectAll('text').data(labelData, d=>d.key)
    .join('text')
      .text(d => d.key === 'unknown' ? 'Unknown' : d.key)
      .attr('text-anchor','end');
  yearLabelSel.attr('x', 80)
              .attr('y', d => (d.line - minYear) * yearSpacing + 55);
}

function applyLayoutForces(restartAlpha = true) {
    simulation.stop();
    nodes.forEach(n => {
        if (layoutMode === 'force') { // only unpin if not focused in force mode
            if (!currentFilters.focus.nodeId || n.id !== currentFilters.focus.nodeId) {
                n.fx = n.fy = null;
            }
        } else { // For tiers, fx/fy are determined by computeYearLayout
            n.fx = n.fy = null; 
        }
    });

    if (layoutMode === 'tiers') {
        computeYearLayout();
        yearLabelGroup.style('display', null);
        nodes.forEach(n => {
            n.fx = n.x; // Use computed x,y from computeYearLayout
            n.fy = n.y;
        });
        ticked(); // Update positions immediately
    } else if (layoutMode === 'force') {
        simulation.force('tier', null);
        yearLabelGroup.style('display', 'none');
        if (restartAlpha) simulation.alpha(1).restart();
        else if (simulation.alpha() < 0.1) simulation.alphaTarget(0.1).restart(); // Gentle reheat if cooled
    }
}

function highlightSearch(){
  const term = currentFilters.searchTerm;
  nodeSel.classed('search-match', d => term !== '' && d.name.toLowerCase().includes(term));
}

function updateHash(){
  const params = new URLSearchParams(location.hash.slice(1));
  if(currentFilters.focus.nodeId !== null){
    params.set('focus', currentFilters.focus.nodeId);
    params.set('depth', currentFilters.focus.depth);
  } else {
    params.delete('focus');
    params.delete('depth');
  }
  history.replaceState(null, '', '#'+params.toString());
}


function setFocus(nodeId, depth) {
    const oldFocusNodeId = currentFilters.focus.nodeId;
    if (oldFocusNodeId && nodeById.has(oldFocusNodeId)) {
        const oldNode = nodeById.get(oldFocusNodeId);
        if (oldNode) { // Unpin previous focus
             oldNode.fx = null;
             oldNode.fy = null;
        }
    }

    currentFilters.focus.nodeId = nodeId;
    currentFilters.focus.depth = nodeId === null ? 1 : parseInt(depth, 10);

    if (nodeId !== null) {
        const node = nodeById.get(nodeId);
        if (node) {
            focusLabel.textContent = 'Focus: ' + node.name;
            focusBox.style.display = 'flex';
            focusRange.value = currentFilters.focus.depth;
            focusNum.textContent = currentFilters.focus.depth;
            // Pinning is handled by applyAllFiltersAndRefresh
        } else { 
            currentFilters.focus.nodeId = null; 
            focusBox.style.display = 'none';
        }
    } else {
        focusBox.style.display = 'none';
    }
    updateHash(); 
    applyAllFiltersAndRefresh(); 
}


function applyAllFiltersAndRefresh(restartSimForcefully = false) {
    let visibleNodeIds = new Set(nodes.map(n => n.id)); // Start with all nodes

    // 1. Apply Year Filter
    if (yearSlider.noUiSlider && currentFilters.year.min !== null && currentFilters.year.max !== null) {
        const [minY, maxY] = [currentFilters.year.min, currentFilters.year.max];
        let yearFilteredNodes = new Set();
        nodes.forEach(n => {
            const y = parseInt(n.birth_year, 10);
            if (isNaN(y) || (y >= minY && y <= maxY)) { // Keep nodes with no year or within range
                yearFilteredNodes.add(n.id);
            }
        });
        visibleNodeIds = yearFilteredNodes;
    }

    // 2. Apply Focus Filter
    let isFocusActive = false;
    let finalVisibleNodeIds = new Set(visibleNodeIds); // Copy before focus potentially reduces it

    if (currentFilters.focus.nodeId !== null && nodeById.has(currentFilters.focus.nodeId)) {
        const focusNodeObject = nodeById.get(currentFilters.focus.nodeId);
        if (visibleNodeIds.has(currentFilters.focus.nodeId)) { // Only apply focus if the focus node itself is year-visible
            isFocusActive = true;
            const focusNeighborhood = new Set([currentFilters.focus.nodeId]);
            let frontier = [currentFilters.focus.nodeId];
            const allNodeIdsInData = new Set(nodes.map(n => n.id));

            for (let i = 0; i < currentFilters.focus.depth; i++) {
                const nextFrontier = [];
                frontier.forEach(id => {
                    links.forEach(l => {
                        if (l.id1 === id || l.id2 === id) {
                            const other = (l.id1 === id) ? l.id2 : l.id1;
                            if (allNodeIdsInData.has(other) && !focusNeighborhood.has(other)) {
                                focusNeighborhood.add(other);
                                nextFrontier.push(other);
                            }
                        }
                    });
                });
                frontier = nextFrontier;
            }
            // Intersect year-visible nodes with focus neighborhood
            finalVisibleNodeIds = new Set([...visibleNodeIds].filter(id => focusNeighborhood.has(id)));
        } else {
             // Focused node is not year-visible, so treat as no effective focus for display
             // but keep currentFilters.focus.nodeId so focus box remains
        }
    }
    
    // Unpin all nodes first, then pin the focus node if active and visible
    nodes.forEach(n => {
        if (layoutMode === 'force') { // Only manage fx/fy for force layout here
             n.fx = null; n.fy = null;
        }
    });

    if (isFocusActive && finalVisibleNodeIds.has(currentFilters.focus.nodeId)) {
        const focusNodeObject = nodeById.get(currentFilters.focus.nodeId);
        if (focusNodeObject && (layoutMode === 'force')) {
            focusNodeObject.fx = focusNodeObject.x; 
            focusNodeObject.fy = focusNodeObject.y;
        }
    }


    // 3. Update Node Selections and Styles
    nodeSel.style('display', d => finalVisibleNodeIds.has(d.id) ? null : 'none');
    nodeSel.classed('focus-node', d => isFocusActive && d.id === currentFilters.focus.nodeId && finalVisibleNodeIds.has(d.id));

    // 4. Determine Global `visibleLinks`
    visibleLinks = links.filter(l => finalVisibleNodeIds.has(l.id1) && finalVisibleNodeIds.has(l.id2));

    // 5. Refresh Link Selections (and potentially simulation)
    // Determine if simulation needs a strong restart based on filter changes or explicit request
    let needsStrongRestart = restartSimForcefully || (layoutMode === 'force' && (isFocusActive || currentFilters.focus.nodeId === null));
    refreshLinks(needsStrongRestart); 

    // 6. Style Focused Edges
    linkSel.classed('focus-edge', false); 
    if (isFocusActive && finalVisibleNodeIds.has(currentFilters.focus.nodeId)) {
        linkSel.filter(d_sim => d_sim.link && (d_sim.link.id1 === currentFilters.focus.nodeId || d_sim.link.id2 === currentFilters.focus.nodeId))
               .classed('focus-edge', true);
    }

    // 7. Apply search term highlighting
    highlightSearch();

    // 8. If layout is static and sim wasn't restarted, ensure positions are updated
    if (!needsStrongRestart && layoutMode === 'tiers') {
        ticked();
    }
}


function setupSearchAndFilter(){
  const years = nodes.map(n => parseInt(n.birth_year, 10)).filter(y => !isNaN(y));
  if(years.length){
    const minY = Math.min(...years);
    const maxY = Math.max(...years);
    noUiSlider.create(yearSlider, {
      start:[minY, maxY], connect:true, step:1,
      range:{min:minY, max:maxY}, tooltips:true,
      format:{to:v=>Math.round(v), from:v=>+v}
    });
    // Initialize currentFilters.year
    currentFilters.year.min = minY;
    currentFilters.year.max = maxY;

    yearSlider.noUiSlider.on('update', (values) => {
      currentFilters.year.min = parseInt(values[0], 10);
      currentFilters.year.max = parseInt(values[1], 10);
      applyAllFiltersAndRefresh();
    });
  } else {
    yearSlider.style.display = 'none';
  }

  searchInput.addEventListener('input', () => {
    currentFilters.searchTerm = searchInput.value.trim().toLowerCase();
    applyAllFiltersAndRefresh(false); // Search is visual, no need to forcefully restart sim
  });

  focusRange.addEventListener('input', () => {
    const newDepth = parseInt(focusRange.value,10);
    if(currentFilters.focus.nodeId !== null){
      // Call setFocus to update depth and refresh, it will also update focusNum
      setFocus(currentFilters.focus.nodeId, newDepth);
    } else { // Update UI even if no node is focused, for next time
        currentFilters.focus.depth = newDepth;
        focusNum.textContent = newDepth;
    }
  });
}

function refreshLinks(restartSim = true){
  const simLinks = buildSimLinks(visibleLinks);

  linkSel = linkGroup.selectAll('path.link').data(simLinks, d => links.indexOf(d.link))
    .join(
      enter => enter.append('path').attr('class','link')
                   .attr('stroke','#555').attr('stroke-width',1.5)
                   .attr('marker-end','url(#arrow)')
                   .on('click', edgeMenu),
      update => update, // No need to re-apply static attributes if not changed
      exit   => exit.remove()
    );

  linkHitSel = linkGroup.selectAll('path.link-hit').data(simLinks, d => links.indexOf(d.link))
    .join(
      enter => enter.append('path').attr('class','link-hit').on('click', edgeMenu),
      update => update,
      exit   => exit.remove()
    );

  labelSel = linkGroup.selectAll('text.label').data(simLinks, d => links.indexOf(d.link))
  .join(
    enter => enter.append('text').attr('class','label')
                  .text(d => d.label)
                  .on('dblclick', (event,d) => {
                    event.stopPropagation();
                    openEdgePopup(d.link, event.pageX, event.pageY);
                  })
                  .on('click', edgeMenu),
    update => update.text(d => d.label),
    exit   => exit.remove()
  );

  simulation.force('link').links(simLinks);
  if (restartSim) {
    applyLayoutForces(true); // true for full alpha restart
  } else {
    if (layoutMode === 'force' && simulation.alpha() < 0.05) { // If cooled down too much
        simulation.alphaTarget(0.1).restart(); // Gentle reheat
    }
    ticked(); // Always update positions
  }
}


function updateGraph(skipSelectUpdate = false, highlightIdx = null, markDirty = true) {
  nodeSel = g.selectAll('.node').data(nodes, d => d.id)
    .join(
      enter => {
        const nodeG = enter.append('g').attr('class', 'node')
          .on('click', (event,d) => {
            event.stopPropagation();
            openNodePopup(d.id, event.pageX, event.pageY);
          })
          .on('dblclick', (event,d)=>{
            event.stopPropagation();
            if(currentFilters.focus.nodeId === d.id){
              setFocus(null, 1); // Unfocus
            } else {
              setFocus(d.id, currentFilters.focus.depth); // Focus
            }
          })
          .call(d3.drag().on('start', dragstarted)
                       .on('drag',  dragged)
                       .on('end',   dragended));

        nodeG.append('circle').attr('r', 22);
        nodeG.append('image').attr('class','node-image')
             .attr('clip-path','url(#nodeClip)')
             .attr('x',-22).attr('y',-22)
             .attr('width',44).attr('height',44)
             .attr('href', d => d.image || '')
             .style('display', d => d.image ? null : 'none');
        nodeG.append('text').attr('dominant-baseline', 'central')
             .text(d => formatNodeLabel(d));
        return nodeG;
      },
      update => update.each(function(d){
        const n = d3.select(this);
        n.on('click', (event)=>{ // Rebind for existing nodes
          event.stopPropagation();
          openNodePopup(d.id, event.pageX, event.pageY);
        })
        .on('dblclick', (event)=>{ // Rebind for existing nodes
          event.stopPropagation();
          if(currentFilters.focus.nodeId === d.id){
            setFocus(null, 1);
          } else {
            setFocus(d.id, currentFilters.focus.depth);
          }
        });
        n.select('text').text(formatNodeLabel(d));
        n.select('image.node-image')
         .attr('href', d.image || '')
         .style('display', d.image ? null : 'none');
      }),
      exit   => exit.remove()
    );

  simulation.nodes(nodes); 

  if (!skipSelectUpdate) populateSelects();
  refreshExport(markDirty);
  
  applyAllFiltersAndRefresh(true); // Forcefully refresh and restart sim for new data

  if (highlightIdx !== null) {
    linkSel.filter(d_sim => links.indexOf(d_sim.link) === highlightIdx)
           .classed('highlight', true)
           .transition().delay(10000)
           .on('end', function () { d3.select(this).classed('highlight', false); });
  }
}


function openEdgePopup(linkObj, x, y) {
  edgePopupLink = linkObj;
  edgePopupLabel.value = linkObj.label || '';
  edgePopup.style.left = (x + 5) + 'px';
  edgePopup.style.top  = (y + 5) + 'px';
  edgePopup.style.display = 'block';
}

function edgeMenu(event, d) {
  if (event.detail > 1) return; 
  event.stopPropagation();
  if (!d || !d.link) return;
  openEdgePopup(d.link, event.pageX, event.pageY);
}

function hideEdgePopup() {
  edgePopup.style.display = 'none';
  edgePopupLink = null;
}

function deleteImageFile(id, path){
  fetch('/delete_image', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ node_id: id, image: path })
  });
}

function renderNodeImages(n){
  nodePopupImages.innerHTML = '';
  (n.images || []).forEach((src, idx) => {
    const wrap = document.createElement('div'); wrap.className = 'item';
    const img = document.createElement('img'); img.src = src;
    wrap.appendChild(img);
    const actions = document.createElement('div'); actions.className = 'actions';
    const left = document.createElement('button'); left.textContent = '\u25C0';
    left.addEventListener('click', () => moveImage(idx,-1));
    const right = document.createElement('button'); right.textContent = '\u25B6';
    right.addEventListener('click', () => moveImage(idx,1));
    const del = document.createElement('button'); del.textContent = 'X';
    del.addEventListener('click', () => removeImage(idx));
    actions.appendChild(left); actions.appendChild(right); actions.appendChild(del);
    wrap.appendChild(actions);
    nodePopupImages.appendChild(wrap);
  });
}

function moveImage(idx, delta){
  const n = nodeById.get(nodePopupId); if(!n) return;
  const imgs = n.images; const newIdx = idx + delta;
  if(newIdx < 0 || newIdx >= imgs.length) return;
  [imgs[idx], imgs[newIdx]] = [imgs[newIdx], imgs[idx]];
  n.image = imgs[0] || null;
  renderNodeImages(n); updateGraph();
}

function removeImage(idx){
  const n = nodeById.get(nodePopupId); if(!n) return;
  const [img] = n.images.splice(idx,1);
  deleteImageFile(n.id, img);
  n.image = n.images[0] || null;
  renderNodeImages(n); updateGraph();
}

async function dedupeImages(n){
  if (!n || !n.images || n.images.length === 0) return;
  const hashes = new Map();
  for(let i=0;i<n.images.length;i++){
    const src = n.images[i];
    try{
      const ab = await fetch(src).then(r=>r.arrayBuffer());
      const hashBuf = await crypto.subtle.digest('SHA-256', ab);
      const hash = Array.from(new Uint8Array(hashBuf)).map(b=>b.toString(16).padStart(2,'0')).join('');
      if(hashes.has(hash)){
        deleteImageFile(n.id, src);
        n.images.splice(i,1); i--;
      }else{ hashes.set(hash, src); }
    }catch(e){console.error(e);}
  }
  n.image = n.images[0] || null;
}

function openNodePopup(id, x, y) {
  const n = nodeById.get(id); if (!n) return;
  nodePopupId = id;
  nodePopupImages.innerHTML = ''; 
  nodePopupName.value = n.name || '';
  nodePopupYear.value = n.birth_year || '';
  const curId = id;
  dedupeImages(n).then(()=>{ if(nodePopupId === curId) renderNodeImages(n); });
  nodePopup.style.left = (x + 5) + 'px';
  nodePopup.style.top  = (y + 5) + 'px';
  nodePopup.style.display = 'block';
  nodePopupName.focus();
}

function hideNodePopup() {
  nodePopup.style.display = 'none';
  nodePopupId = null;
}

nodePopupSave.addEventListener('click', e => {
  e.stopPropagation(); if (nodePopupId === null) return;
  const n = nodeById.get(nodePopupId);
  n.name = nodePopupName.value.trim() || n.name;
  const year = nodePopupYear.value.trim();
  if (year === '') delete n.birth_year; else n.birth_year = year;
  hideNodePopup();
  // populateSelects(); // updateGraph will call this via applyAllFiltersAndRefresh->populateSelects
  updateGraph();
});

nodePopupDelete.addEventListener('click', e => {
  e.stopPropagation(); if (nodePopupId === null) return;
  const id = nodePopupId;
  const idx = nodes.findIndex(n=>n.id===id);
  if (idx !== -1) nodes.splice(idx,1);
  links = links.filter(l=>l.id1!==id && l.id2!==id);
  nodeById.delete(id);
  if (currentFilters.focus.nodeId === id) { // If deleted node was focused
    setFocus(null, 1); // Unfocus
  }
  hideNodePopup();
  updateGraph();
});

nodePopupClose.addEventListener('click', e => { e.stopPropagation(); hideNodePopup(); });

edgePopupSave.addEventListener('click', e => {
  e.stopPropagation(); if (!edgePopupLink) return;
  edgePopupLink.label = edgePopupLabel.value;
  hideEdgePopup(); updateGraph();
});
edgePopupReverse.addEventListener('click', e => {
  e.stopPropagation(); if (!edgePopupLink) return;
  const l = edgePopupLink; [l.id1, l.id2] = [l.id2, l.id1];
  hideEdgePopup();
  applyAllFiltersAndRefresh(false); // No need for full sim restart, just update links
  refreshExport();
});
edgePopupDelete.addEventListener('click', e => {
  e.stopPropagation(); if (!edgePopupLink) return;
  const idx = links.indexOf(edgePopupLink);
  if (idx !== -1) links.splice(idx, 1);
  hideEdgePopup(); updateGraph();
});
edgePopupClose.addEventListener('click', e => { e.stopPropagation(); hideEdgePopup(); });
document.body.addEventListener('click', e => {
  if (!edgePopup.contains(e.target)) hideEdgePopup();
  if (!nodePopup.contains(e.target)) hideNodePopup();
});


/* ---------- drag handlers ---------- */
function dragstarted(event,d){
  if(layoutMode === 'force'){
    if(d.id === currentFilters.focus.nodeId && finalVisibleNodeIds.has(d.id)) return; // Prevent drag on visible focused node
    if(!event.active) simulation.alphaTarget(0.3).restart();
    d.fx=d.x; d.fy=d.y;
  }
}
function dragged(event,d){
  if(layoutMode === 'force'){
    if(d.id === currentFilters.focus.nodeId && finalVisibleNodeIds.has(d.id)) return;
    d.fx=event.x; d.fy=event.y;
  } else { // Tiers mode - allow dragging, but it won't stick unless focus logic re-pins
    if(d.id === currentFilters.focus.nodeId && finalVisibleNodeIds.has(d.id)) return; // Still prevent if focused for consistency
    d.x = event.x; d.y = event.y;
    ticked(); // Manually update positions in tiers mode during drag
  }
}
function dragended(event,d){
  if(layoutMode === 'force'){
    if(d.id === currentFilters.focus.nodeId && finalVisibleNodeIds.has(d.id)) return; // Remain fixed if focused
    if(!event.active) simulation.alphaTarget(0);
    // Do not nullify fx, fy if it's the focused node.
    // applyAllFiltersAndRefresh handles fx/fy for the focused node.
    if (d.id !== currentFilters.focus.nodeId) {
        d.fx=null; d.fy=null;
    }
  } else { // Tiers mode
      // If it was the focused node, re-apply its fixed position from layout
      if (d.id === currentFilters.focus.nodeId && finalVisibleNodeIds.has(d.id)) {
          const focusedNode = nodeById.get(d.id);
          computeYearLayout(); // Recompute to get its theoretical position
          d.fx = focusedNode.x; // Re-pin to its tier position
          d.fy = focusedNode.y;
      }
    ticked(); // Update positions
  }
}

/* ---------- UI events ---------- */
document.getElementById('perturb').addEventListener('click',()=>{
  nodes.forEach(n=>{
    n.x += (Math.random()-0.5)*40;
    n.y += (Math.random()-0.5)*40;
  });
  if (layoutMode === 'force') simulation.alpha(0.8).restart();
  else ticked();
});

document.getElementById('dampen').addEventListener('click',()=>{
  nodes.forEach(n=>{
    n.vx = (n.vx || 0) * 0.5;
    n.vy = (n.vy || 0) * 0.5;
  });
});

chargeInput.addEventListener('input', e=>{
  simulation.force('charge').strength(+e.target.value);
  if (layoutMode === 'force') simulation.alpha(0.8).restart(); else ticked();
});

linkInput.addEventListener('input', e=>{
  simulation.force('link').distance(+e.target.value);
  if (layoutMode === 'force') simulation.alpha(0.8).restart(); else ticked();
});

layoutSelect.addEventListener('change', e => {
  layoutMode = e.target.value;
  applyLayoutForces(); // This sets up fx/fy for tiers or clears for force
  applyAllFiltersAndRefresh(true); // Re-apply filters and ensure pinning is correct for new layout
});

document.addEventListener('paste', e => {
  if(nodePopupId === null) return;
  const item = Array.from(e.clipboardData.items).find(i=>i.type.startsWith('image/'));
  if(!item) return;
  const file = item.getAsFile();
  uploadImage(nodePopupId, file);
});

function uploadImage(id, file){
  const fd = new FormData();
  fd.append('node_id', id);
  fd.append('image', file, file.name || 'clipboard.png');
  fetch('/upload', {method:'POST', body:fd})
    .then(r => r.ok ? r.text() : Promise.reject())
    .then(resp => {
      if(resp === 'DUPLICATE') return;
      const n = nodeById.get(id);
      if(!n.images) n.images = [];
      n.images.push(`images/${resp}`);
      n.image = n.images[0] || null;
      dedupeImages(n).then(()=>{
        updateGraph(); // This will refresh node visuals and call applyAllFiltersAndRefresh
        if(nodePopupId === id) renderNodeImages(n);
      });
    });
}

/* add node */
function addNode() {
  const inp      = document.getElementById('newNodeName');
  const yearInp  = document.getElementById('newNodeYear');
  const name     = inp.value.trim();
  const year     = yearInp.value.trim();
  if (!name) return;

  const id = nextNodeId++;
  const newNodeData = { id, name, images: [] }; // Ensure images array exists
  if (year !== '') newNodeData.birth_year = year;
  nodes.push(newNodeData);
  nodeById.set(id, nodes[nodes.length - 1]);

  const fromVal  = edgeFrom.value;
  const labelVal = edgeLabel.value;
  inp.value = ''; yearInp.value = '';

  updateGraph(true); // Refresh graph with new node, skip select update for now

  // updateGraph calls populateSelects indirectly via applyAllFiltersAndRefresh
  // So, we can set edgeTo and edgeFrom *after* updateGraph completes its full cycle if needed,
  // but populateSelects() inside updateGraph should handle new node.
  // For now, direct populateSelects is fine if updateGraph's internal one is too late.
  populateSelects(); 

  edgeFrom.value = fromVal;
  $(edgeTo).val(id).trigger('change'); // Set new node as 'to' and trigger select2 update
  edgeLabel.value = labelVal;
}

document.getElementById('addNodeBtn').addEventListener('click', addNode);
document.getElementById('newNodeName').addEventListener('keydown', e => { if (e.key === 'Enter') addNode(); });
document.getElementById('newNodeYear').addEventListener('keydown', e => { if (e.key === 'Enter') addNode(); });

/* add edge */
addEdgeBtn.addEventListener('click', () => {
  const id1 = parseInt(edgeFrom.value, 10);
  const id2 = parseInt(edgeTo.value,   10);
  const lbl = edgeLabel.value.trim() || '';

  if (isNaN(id1) || isNaN(id2) || id1 === id2) return;
  links.push({ id1, id2, label: lbl });
  edgeLabel.value = '';
  updateGraph(true, links.length - 1);
});

/* ---------- initial render ---------- */
loadData().then(() => {
  populateSelects(); // Initial population before setupSearchAndFilter
  setupSearchAndFilter(); // Initializes year slider and sets currentFilters.year

  updateGraph(false, null, false); // Initial graph draw, calls applyAllFiltersAndRefresh internally

  // Parse URL hash for focus after initial graph setup
  const params = new URLSearchParams(location.hash.slice(1));
  let initialFocusNodeId = null;
  let initialFocusDepth = 1;

  if (params.has('focus')) {
    initialFocusNodeId = parseInt(params.get('focus'), 10);
    initialFocusDepth = parseInt(params.get('depth') || '1', 10);
  }

  if (initialFocusNodeId !== null && nodeById.has(initialFocusNodeId)) {
      setFocus(initialFocusNodeId, initialFocusDepth); // This will trigger applyAllFiltersAndRefresh
  } else {
      applyAllFiltersAndRefresh(false); // Apply default filters (e.g., year) if no URL focus
  }
});

$(document).on('select2:open', function() {
  document.querySelector('.select2-container--open .select2-search__field').focus();
});
</script>
</body>
</html>