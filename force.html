<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Force‑Directed People Graph</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/css/select2.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.full.min.js"></script>
  <style>
    html,body{margin:0;height:100%;background:#fff;font-family:Arial,Helvetica,sans-serif}
    #topControls,#bottomControls{display:flex;gap:12px;padding:8px;flex-wrap:wrap}
    #topControls{border-bottom:1px solid #ddd}
    #bottomControls{border-top:1px solid #ddd}
    #graph{width:100%;height:calc(100% - 120px)} /* two control bars */

    textarea#export{
      position:fixed;
      bottom:10px;
      right:10px;
      width:240px;
      height:160px;
      border:1px solid #ccc;
      resize:none;
      font-family:monospace;
      padding:6px;
      box-sizing:border-box;
      background:#fff;
    }
    textarea#export.unsaved{background:#fff3c4}

    .node circle{fill:#a7d3ff;stroke:#fff;stroke-width:2px;cursor:grab}
    .node-image{pointer-events:none}
    
    .link{stroke:#555;stroke-width:1.5px;fill:none;marker-end:url(#arrow)}
    .link.highlight{stroke:red;stroke-width:3px}
    text{font-size:12px;pointer-events:none;fill:#000}
    .label{pointer-events:all;cursor:pointer}
    .link-hit{stroke:transparent;stroke-width:14px;fill:none;cursor:pointer}
    button{cursor:pointer}
    #edgePopup{position:absolute;background:#ffffe0;border:1px solid #aaa;border-radius:4px;padding:4px;font-size:12px;box-shadow:0 2px 4px rgba(0,0,0,0.2);display:none}
    #edgePopup input{width:120px}
    #edgePopup .actions{display:flex;gap:4px;margin-top:4px}

    #nodePopup{position:absolute;background:#ffffe0;border:1px solid #aaa;border-radius:4px;padding:4px;font-size:12px;box-shadow:0 2px 4px rgba(0,0,0,0.2);display:none}
    #nodePopup input{width:120px;display:block;margin-top:4px}
    #nodePopup .actions{display:flex;gap:4px;margin-top:4px}
    #nodePopup .hint{font-style:italic;margin-top:4px;font-size:11px}
    #nodePopupImage{display:none;margin-top:4px}
    
    /* bigger add buttons */
    #addNodeBtn,#addEdgeBtn{font-size:16px;padding:6px 12px}

    #layoutLabel{margin-left:auto}
  </style>
</head>
<body>
  <!-- top toolbar -->
  <div id="topControls">
    <button id="perturb">Perturb</button>
    <button id="dampen">Remove Momentum</button>
    <label>Charge <input id="chargeRange" type="range" min="-1000" max="0" value="-300"></label>
    <label>Link&nbsp;Dist <input id="linkRange" type="range" min="30" max="300" value="150"></label>
    <label id="layoutLabel">Layout
      <select id="layoutSelect">
        <option value="force">Force</option>
        <option value="tiers">Tiers</option>
      </select>
    </label>
  </div>

  <!-- graph area -->
  <div id="graph"></div>

  <!-- bottom toolbar -->
<div id="bottomControls">
  <label>Add Node
    <input id="newNodeName" type="text" placeholder="Name">
    <input id="newNodeYear" type="text" placeholder="Birth Year">
    <button id="addNodeBtn">Add</button>
  </label>
  <label>Add Edge from
    <select id="edgeFrom"></select> to
    <select id="edgeTo"></select> label
    <input id="edgeLabel" type="text" placeholder="Label" list="presetLabels">
    <button id="addEdgeBtn">Add</button>
  </label>
  <datalist id="presetLabels">
    <option value="read">
    <option value="liked">
    <option value="inspired by">
    <option value="friend">
  </datalist>
</div>

  <!-- export area -->
  <textarea id="export" readonly></textarea>

  <!-- edge action popup -->
  <div id="edgePopup">
    <input id="edgePopupLabel" type="text">
    <div class="actions">
      <button id="edgePopupSave">Save</button>
      <button id="edgePopupReverse">Reverse</button>
      <button id="edgePopupDelete">Delete</button>
      <button id="edgePopupClose">X</button>
    </div>
  </div>

  <!-- node action popup -->
  <div id="nodePopup">
    <input id="nodePopupName" type="text" placeholder="Name">
    <input id="nodePopupYear" type="text" placeholder="Birth Year">
    <div class="actions">
      <button id="nodePopupSave">Save</button>
      <button id="nodePopupDelete">Delete</button>
      <button id="nodePopupClose">X</button>
    </div>
    <div class="hint">Paste an image while this popup is open</div>
    <img id="nodePopupImage" />
  </div>

<script>
/* ---------- data loading ---------- */
/*
  data.json format:
  {
    "nodes": [
      {"id":1,"name":"Name","birth_year":"1879","image":"images/1.png"}
    ],
    "links": [{"id1":1,"id2":2,"label":"label"}]
  }
  birth_year and image are optional per node.
*/
let nodes = [];
let links = [];
const nodeById = new Map();
let nextNodeId = 1;
function loadData(){
  return fetch("data.json")
    .then(r=>r.json())
    .then(data=>{
      nodes = data.nodes || [];
      links = data.links || [];
      nodes.forEach(n=>{
        if(!('image' in n)) n.image = null;
        nodeById.set(n.id,n);
      });
      nextNodeId = Math.max(0,...nodes.map(n=>n.id)) + 1;
    });
}

function buildSimLinks() {
  return links.map(e => ({
    source : nodeById.get(e.id1),
    target : nodeById.get(e.id2),
    label  : e.label,
    dir    : e.id1 < e.id2 ? 1 : -1    // A→B “up”, B→A “down”
  }));
}

/* ---------- SVG & defs ---------- */
const graphDiv = document.getElementById('graph');
const width    = graphDiv.clientWidth;
const height   = graphDiv.clientHeight;

const svg = d3.select(graphDiv).append('svg')
              .attr('width',width)
              .attr('height',height);

/* ---------- zoom & pan ---------- */
const zoom = d3.zoom()
  .scaleExtent([0.1, 4])                     // min / max zoom
  .on('zoom', event => g.attr('transform', event.transform));

svg.call(zoom).on('dblclick.zoom', null);     // disable dblclick-to-zoom

svg.append('defs').append('marker')
   .attr('id','arrow')
   .attr('viewBox','0 -5 10 10')
   .attr('refX',32).attr('refY',0) /* offset beyond circle */
   .attr('markerWidth',8).attr('markerHeight',8)
   .attr('orient','auto')
   .append('path').attr('d','M0,-5L10,0L0,5').attr('fill','#555');

const g = svg.append('g');
const linkGroup = g.append('g').attr('class','links');
let  linkSel     = linkGroup.selectAll('path.link');
let  linkHitSel  = linkGroup.selectAll('path.link-hit');
let  labelSel    = linkGroup.selectAll('text.label');
let  nodeSel     = g.selectAll('.node');

const BASE_COLLISION  = 40;  // default collision distance
const LABEL_OFFSET    = 6;   // px text sits beyond circle

/* ---------- D3 forces ---------- */
const chargeInput = document.getElementById('chargeRange');
const linkInput   = document.getElementById('linkRange');
const layoutSelect= document.getElementById('layoutSelect');
let   layoutMode  = layoutSelect.value;
const yearSpacing = 20;
const exportArea  = document.getElementById('export');   // ← new
const edgePopup       = document.getElementById('edgePopup');
const edgePopupLabel  = document.getElementById('edgePopupLabel');
const edgePopupSave   = document.getElementById('edgePopupSave');
const edgePopupReverse= document.getElementById('edgePopupReverse');
const edgePopupDelete = document.getElementById('edgePopupDelete');
const edgePopupClose  = document.getElementById('edgePopupClose');
let   edgePopupIndex  = null;

const nodePopup       = document.getElementById('nodePopup');
const nodePopupName   = document.getElementById('nodePopupName');
const nodePopupYear   = document.getElementById('nodePopupYear');
const nodePopupSave   = document.getElementById('nodePopupSave');
const nodePopupDelete = document.getElementById('nodePopupDelete');
const nodePopupClose  = document.getElementById('nodePopupClose');
const nodePopupImage  = document.getElementById('nodePopupImage');
let   nodePopupId     = null;

const simulation = d3.forceSimulation(nodes)
  .force('link',
         d3.forceLink()                       // links injected later
           .id(d => d.id)
           .distance(() => +linkRange.value))
  .force('charge',
         d3.forceManyBody()
           .strength(() => +chargeRange.value)        // live-updates with slider
           .distanceMax(1_000000))                       // repulse across whole graph
  .force('center', d3.forceCenter(width / 2, height / 2))
  .force('collision', d3.forceCollide().radius(40))
  .alphaDecay(0.001)                                  // cools more slowly → runs longer
  .on('tick', ticked);

function ticked(){
  /* ---------- arrow path ---------- */
  const r = 22;
  const pathD = d => {
    const dx   = d.target.x - d.source.x,
          dy   = d.target.y - d.source.y,
          dist = Math.hypot(dx, dy) || 1,
          tEnd   = (dist - r) / dist;  // line ends at target circle

    return `M${d.source.x},${d.source.y}L${d.source.x + dx*tEnd},${d.source.y + dy*tEnd}`;
  };

  linkSel.attr('d', pathD);
  linkHitSel.attr('d', pathD);

  /* keep nodes visible & movable */
  nodeSel.attr('transform', d => `translate(${d.x},${d.y})`);
  
	/* ---------- node name “radial-slot” positioning ---------- */
// gather incident edge angles for each node this tick
const incident = new Map();  // node.id → [angles]

links.forEach(l => {
  const src = nodeById.get(l.id1),
        tgt = nodeById.get(l.id2);
  if (!src || !tgt) return;

  const a = Math.atan2(tgt.y - src.y, tgt.x - src.x);   // angle src→tgt
  (incident.get(src.id) || incident.set(src.id, []).get(src.id)).push(a);
  (incident.get(tgt.id) || incident.set(tgt.id, []).get(tgt.id)).push(a + Math.PI); // opposite at tgt
});

// eight slot angles (0°,45°,…)
const slots       = Array.from({length:8}, (_,i)=>i*Math.PI/4);
const labelRadius = 28; // px from node center
const labelOffset = 6; // px beyond circle

nodeSel.select('text').each(function(d){
  const edges = incident.get(d.id) || [];
  // choose slot farthest from every incident edge
  let bestAng = 0, bestScore = -1;
  slots.forEach(s => {
    const score = edges.length
      ? Math.min(...edges.map(e => Math.abs(Math.atan2(Math.sin(s-e), Math.cos(s-e)))))
      : Math.PI;  // isolated node
    if (score > bestScore){ bestScore = score; bestAng = s; }
  });

  const tx = Math.cos(bestAng) * labelRadius,
        ty = Math.sin(bestAng) * labelRadius;

  d3.select(this)
    .attr('x', tx)
    .attr('y', ty)
    .attr('dominant-baseline', 'central')
    .attr('text-anchor',
          Math.abs(Math.cos(bestAng)) < 0.3 ? 'middle' :
          (Math.cos(bestAng) > 0 ? 'start' : 'end'));
});
	
  /* ---------- label position ---------- */
  const delta     = 10;   // perpendicular offset (px)
  const fracToTgt = 0.65; // label sits 65 % toward target, just behind arrow

  labelSel.each(function (d) {
    /* use lower-ID → higher-ID to define perpendicular direction */
    const forward = d.source.id < d.target.id;
    const s       = forward ? d.source : d.target;
    const t       = forward ? d.target : d.source;
    const dx      = t.x - s.x,
          dy      = t.y - s.y,
          dist    = Math.hypot(dx, dy) || 1,
          px      = -dy / dist,            // unit perpendicular
          py      =  dx / dist,
          dir     = forward ? 1 : -1;      // “up” or “down”

    const lx = d.source.x + (d.target.x - d.source.x) * fracToTgt;
    const ly = d.source.y + (d.target.y - d.source.y) * fracToTgt;

    d.cx = lx + delta * px * dir;
    d.cy = ly + delta * py * dir;
  })
  .attr('x', d => d.cx)
  .attr('y', d => d.cy)
  .attr('text-anchor', 'middle')
  .attr('dominant-baseline', 'central')
  .attr('transform', d => {
    let ang = Math.atan2(d.target.y - d.source.y,
                         d.target.x - d.source.x) * 180 / Math.PI;
    if (ang > 90 || ang < -90) ang += 180;   // keep text upright
    return `rotate(${ang},${d.cx},${d.cy})`;
  });
}

/* ---------- helpers ---------- */

function formatNodeLabel(n){
  return (n.birth_year !== undefined && n.birth_year !== null && n.birth_year !== '')
         ? `${n.name} (${n.birth_year})`
         : n.name;
}

function populateSelects() {
  const sorted = nodes.slice().sort((a, b) => a.name.localeCompare(b.name));
  const opts = sorted
    .map(n => `<option value="${n.id}">${formatNodeLabel(n)}</option>`)
    .join('');

  const fromVal = edgeFrom.value;
  const toVal   = edgeTo.value;

  $(edgeFrom).html(opts);
  $(edgeTo).html(opts);

  $(edgeFrom).val(fromVal);
  $(edgeTo).val(toVal);

  if (!$(edgeFrom).hasClass('select2-hidden-accessible')) {
    $(edgeFrom).select2();
    $(edgeTo).select2();

    // open dropdown on focus for both keyboard and mouse
    $(edgeFrom).next('.select2').find('.select2-selection')
      .off('focus.open')
      .on('focus.open', () => $(edgeFrom).select2('open'));
    $(edgeTo).next('.select2').find('.select2-selection')
      .off('focus.open')
      .on('focus.open', () => $(edgeTo).select2('open'));

    $(edgeFrom)
      .off('focus.open')
      .on('focus.open', () => $(edgeFrom).select2('open'));
    $(edgeTo)
      .off('focus.open')
      .on('focus.open', () => $(edgeTo).select2('open'));

    // autofocus search field when dropdown opens
    const focusSearch = () =>
      setTimeout(() => {
        $('.select2-container--open .select2-search__field').last().trigger('focus');
      }, 0);

    $(edgeFrom)
      .off('select2:open')
      .on('select2:open', focusSearch);
    $(edgeTo)
      .off('select2:open')
      .on('select2:open', focusSearch);
  } else {
    $(edgeFrom).trigger('change.select2');
    $(edgeTo).trigger('change.select2');
  }
}


exportArea.addEventListener('click', () => {
  navigator.clipboard.writeText(exportArea.value)
    .then(() => exportArea.classList.remove('unsaved'));
});

function refreshExport(markDirty = true) {
  exportArea.value = JSON.stringify({
    nodes: nodes.map(n => {
      const obj = { id: n.id, name: n.name };
      if (n.birth_year !== undefined && n.birth_year !== null && n.birth_year !== '') obj.birth_year = n.birth_year;
      if (n.image) obj.image = n.image;
      return obj;
    }),
    links
  }, null, 2);
  if (markDirty) {
    exportArea.classList.add('unsaved');
  } else {
    exportArea.classList.remove('unsaved');
  }
}

function computeTiers() {
  // determine minimum known birth year
  let minYear = Infinity;
  nodes.forEach(n => {
    const y = parseInt(n.birth_year, 10);
    if (!isNaN(y) && y < minYear) minYear = y;
  });
  if (!isFinite(minYear)) minYear = 0;

  // assign tier based on birth year (earliest at tier 0)
  nodes.forEach(n => {
    const y = parseInt(n.birth_year, 10);
    n.tier = isNaN(y) ? null : (y - minYear);
  });
}

function applyLayoutForces() {
  if (layoutMode === 'tiers') {
    computeTiers();
    simulation.force('tier', null); // vertical fixed by fy
    nodes.forEach(n => {
      if (n.tier !== null) {
        n.fy = n.tier * yearSpacing;
        n.y  = n.fy;
      } else {
        n.fy = null;
      }
    });
  } else {
    simulation.force('tier', null);
    nodes.forEach(n => n.fy = null);
  }
}

function updateGraph(skipSelectUpdate = false, highlightIdx = null, markDirty = true) {
  const simLinks = buildSimLinks();

  /* ---- links ---- */
  linkSel = linkGroup.selectAll('path.link').data(simLinks, (d,i)=>i)
        .join(
                enter => enter.append('path')
                                          .attr('class','link')
                                          .attr('stroke','#555')
                                          .attr('stroke-width',1.5)
                                          .attr('marker-end','url(#arrow)')
                                          .on('click', edgeMenu),
                update => update
                                          .attr('stroke','#555')          // keep base look identical
                                          .attr('stroke-width',1.5)
                                          .attr('marker-end','url(#arrow)')
                                          .on('click', edgeMenu),
                exit   => exit.remove()
          );

  linkHitSel = linkGroup.selectAll('path.link-hit').data(simLinks, (d,i)=>i)
        .join(
                enter => enter.append('path')
                                          .attr('class','link-hit')
                                          .on('click', edgeMenu),
                update => update.on('click', edgeMenu),
                exit   => exit.remove()
          );

  labelSel = linkGroup.selectAll('text.label').data(simLinks, (d,i)=>i)
  .join(
    enter => enter.append('text')
                  .attr('class','label')
                  .text(d => d.label)
                  /* dbl-click label edit */
                  .on('dblclick', (event,d) => {
                    event.stopPropagation();
                    const idx = labelSel.nodes().indexOf(event.currentTarget);
                    if (idx === -1) return;
                    openEdgePopup(idx, event.pageX, event.pageY);
                  })
                  .on('click', edgeMenu),
    update => update.text(d => d.label),
    exit   => exit.remove()
  );

  /* ---- nodes ---- */
nodeSel = g.selectAll('.node').data(nodes, d => d.id)
  .join(
    enter => {
      const nodeG = enter.append('g').attr('class', 'node')
          .on('click', (event,d) => {
            event.stopPropagation();
            openNodePopup(d.id, event.pageX, event.pageY);
          })
          .call(d3.drag().on('start', dragstarted)
                        .on('drag',  dragged)
                        .on('end',   dragended));

      nodeG.append('circle').attr('r', 22);
      nodeG.append('image')
           .attr('class','node-image')
           .attr('x',-22)
           .attr('y',-22)
           .attr('width',44)
           .attr('height',44)
           .attr('href', d => d.image || '')
           .style('display', d => d.image ? null : 'none');
      nodeG.append('text')
           .attr('dominant-baseline', 'central')
           .text(d => formatNodeLabel(d));
      return nodeG;
    },
    update => update.each(function(d){
      const n = d3.select(this);
      n.on('click', (event)=>{
        event.stopPropagation();
        openNodePopup(d.id, event.pageX, event.pageY);
      });
      n.select('text').text(formatNodeLabel(d));
      n.select('image.node-image')
        .attr('href', d.image || '')
        .style('display', d.image ? null : 'none');
    }),
    exit   => exit.remove()
  );

  simulation.nodes(nodes);
  simulation.force('link').links(simLinks);
  applyLayoutForces();
  simulation.alpha(0.6).restart();
  if (layoutMode === 'tiers') {
    setTimeout(() => simulation.stop(), 1000);
  }

  if (!skipSelectUpdate) populateSelects();
  if (highlightIdx !== null) {
    linkSel.filter((d, i) => i === highlightIdx)
           .classed('highlight', true)
           .transition().delay(10000)
           .on('end', function () { d3.select(this).classed('highlight', false); });
  }
  refreshExport(markDirty);
}


function openEdgePopup(idx, x, y) {
  edgePopupIndex = idx;
  edgePopupLabel.value = links[idx].label || '';
  edgePopup.style.left = (x + 5) + 'px';
  edgePopup.style.top  = (y + 5) + 'px';
  edgePopup.style.display = 'block';
}

function edgeMenu(event, d) {
  if (event.detail > 1) return; // ignore double-click
  event.stopPropagation();
  let idx = linkSel.nodes().indexOf(event.currentTarget);
  if (idx === -1) idx = labelSel.nodes().indexOf(event.currentTarget);
  if (idx === -1) idx = linkHitSel.nodes().indexOf(event.currentTarget);
  if (idx === -1) return;

  openEdgePopup(idx, event.pageX, event.pageY);
}

function hideEdgePopup() {
  edgePopup.style.display = 'none';
  edgePopupIndex = null;
}

function openNodePopup(id, x, y) {
  const n = nodeById.get(id);
  if (!n) return;
  nodePopupId = id;
  nodePopupName.value = n.name || '';
  nodePopupYear.value = n.birth_year || '';
  if (n.image) {
    nodePopupImage.src = n.image;
    nodePopupImage.style.display = 'block';
  } else {
    nodePopupImage.style.display = 'none';
  }
  nodePopup.style.left = (x + 5) + 'px';
  nodePopup.style.top  = (y + 5) + 'px';
  nodePopup.style.display = 'block';
  nodePopupName.focus();
}

function hideNodePopup() {
  nodePopup.style.display = 'none';
  nodePopupImage.style.display = 'none';
  nodePopupId = null;
}

nodePopupSave.addEventListener('click', e => {
  e.stopPropagation();
  if (nodePopupId === null) return;
  const n = nodeById.get(nodePopupId);
  n.name = nodePopupName.value.trim() || n.name;
  const year = nodePopupYear.value.trim();
  if (year === '') delete n.birth_year; else n.birth_year = year;
  hideNodePopup();
  populateSelects();
  updateGraph();
});

nodePopupDelete.addEventListener('click', e => {
  e.stopPropagation();
  if (nodePopupId === null) return;
  const id = nodePopupId;
  const idx = nodes.findIndex(n=>n.id===id);
  if (idx !== -1) nodes.splice(idx,1);
  links = links.filter(l=>l.id1!==id && l.id2!==id);
  nodeById.delete(id);
  hideNodePopup();
  populateSelects();
  updateGraph();
});

nodePopupClose.addEventListener('click', e => {
  e.stopPropagation();
  hideNodePopup();
});

edgePopupSave.addEventListener('click', e => {
  e.stopPropagation();
  if (edgePopupIndex === null) return;
  links[edgePopupIndex].label = edgePopupLabel.value;
  hideEdgePopup();
  updateGraph();
});
edgePopupReverse.addEventListener('click', e => {
  e.stopPropagation();
  if (edgePopupIndex === null) return;
  const l = links[edgePopupIndex];
  [l.id1, l.id2] = [l.id2, l.id1];
  hideEdgePopup();
  updateGraph();
});
edgePopupDelete.addEventListener('click', e => {
  e.stopPropagation();
  if (edgePopupIndex === null) return;
  links.splice(edgePopupIndex, 1);
  hideEdgePopup();
  updateGraph();
});
edgePopupClose.addEventListener('click', e => {
  e.stopPropagation();
  hideEdgePopup();
});
document.body.addEventListener('click', e => {
  if (!edgePopup.contains(e.target)) hideEdgePopup();
  if (!nodePopup.contains(e.target)) hideNodePopup();
});


/* ---------- drag handlers ---------- */
function dragstarted(event,d){
  if(!event.active) simulation.alphaTarget(0.3).restart();
  d.fx = event.x;
  if (layoutMode === 'tiers' && d.tier !== null) {
    d.fy = d.tier * yearSpacing;
  } else {
    d.fy = event.y;
  }
}
function dragged(event,d){
  d.fx = event.x;
  if (layoutMode === 'tiers' && d.tier !== null) {
    d.fy = d.tier * yearSpacing;
  } else {
    d.fy = event.y;
  }
}
function dragended(event,d){
  if(!event.active) simulation.alphaTarget(0);
  d.fx = null;
  if (layoutMode === 'tiers' && d.tier !== null) {
    d.fy = d.tier * yearSpacing;
  } else {
    d.fy = null;
  }
}

/* ---------- UI events ---------- */
document.getElementById('perturb').addEventListener('click',()=>{
  nodes.forEach(n=>{
    n.x += (Math.random()-0.5)*40;
    n.y += (Math.random()-0.5)*40;
  });
  simulation.alpha(0.8).restart();
});

document.getElementById('dampen').addEventListener('click',()=>{
  nodes.forEach(n=>{
    n.vx = (n.vx || 0) * 0.5;
    n.vy = (n.vy || 0) * 0.5;
  });
});

chargeInput.addEventListener('input', e=>{
  simulation.force('charge').strength(+e.target.value);
  simulation.alpha(0.8).restart();
});

linkInput.addEventListener('input', e=>{
  simulation.force('link').distance(+e.target.value);
  simulation.alpha(0.8).restart();
});

layoutSelect.addEventListener('change', e => {
  layoutMode = e.target.value;
  applyLayoutForces();
  simulation.alpha(0.8).restart();
});

document.addEventListener('paste', e => {
  if(nodePopupId === null) return;
  const item = Array.from(e.clipboardData.items).find(i=>i.type.startsWith('image/'));
  if(!item) return;
  const file = item.getAsFile();
  uploadImage(nodePopupId, file);
});

function uploadImage(id, file){
  const fd = new FormData();
  fd.append('node_id', id);
  fd.append('image', file, file.name || 'clipboard.png');
  fetch('/upload', {method:'POST', body:fd})
    .then(r => r.ok ? r.text() : Promise.reject())
    .then(() => {
      const n = nodeById.get(id);
      n.image = `images/${id}.png`;
      updateGraph();
      if(nodePopupId === id){
        nodePopupImage.src = n.image;
        nodePopupImage.style.display = 'block';
      }
    });
}

/* add node */
function addNode() {
  const inp      = document.getElementById('newNodeName');
  const yearInp  = document.getElementById('newNodeYear');
  const name     = inp.value.trim();
  const year     = yearInp.value.trim();
  if (!name) return;

  const id = nextNodeId++;
  const obj = { id, name };
  if (year !== '') obj.birth_year = year;
  nodes.push(obj);
  nodeById.set(id, nodes[nodes.length - 1]);

  const fromVal  = edgeFrom.value;   // preserve current "from" selection
  const labelVal = edgeLabel.value;  // preserve label text

  inp.value = '';
  yearInp.value = '';

  updateGraph(true);                 // refresh layout only
  populateSelects();                 // now update dropdowns

  edgeFrom.value = fromVal;          // restore previous "from" selection
  edgeTo.value   = id;               // default "to" to newly added node
  edgeLabel.value = labelVal;        // restore label text
}

document.getElementById('addNodeBtn').addEventListener('click', addNode);
document.getElementById('newNodeName').addEventListener('keydown', e => {
  if (e.key === 'Enter') addNode();
});
document.getElementById('newNodeYear').addEventListener('keydown', e => {
  if (e.key === 'Enter') addNode();
});

/* add edge */
addEdgeBtn.addEventListener('click', () => {
  const id1 = parseInt(edgeFrom.value, 10);
  const id2 = parseInt(edgeTo.value,   10);
  const lbl = edgeLabel.value.trim() || '';

  if (isNaN(id1) || isNaN(id2) || id1 === id2) return;
  links.push({ id1, id2, label: lbl });
  edgeLabel.value = '';
  updateGraph(true, links.length - 1);   // skip select refresh, highlight new link
});

/* ---------- initial render ---------- */
loadData().then(() => {
  populateSelects();
  updateGraph(false, null, false);
});
</script>
</body>
</html>
